<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菊爷杂记</title>
  <subtitle>博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.charleslxh.top/"/>
  <updated>2019-06-27T02:58:32.833Z</updated>
  <id>http://blog.charleslxh.top/</id>
  
  <author>
    <name>Charles Liao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQTT-协议基本详解</title>
    <link href="http://blog.charleslxh.top/2019/06/27/2019/mqtt-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.charleslxh.top/2019/06/27/2019/mqtt-协议基本详解/</id>
    <published>2019-06-27T02:58:33.000Z</published>
    <updated>2019-06-27T02:58:32.833Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MQTT" scheme="http://blog.charleslxh.top/categories/mqtt/"/>
    
    
      <category term="MQTT" scheme="http://blog.charleslxh.top/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>GitLab-CI-持续集成</title>
    <link href="http://blog.charleslxh.top/2019/06/27/2019/gitlab-ci-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>http://blog.charleslxh.top/2019/06/27/2019/gitlab-ci-持续集成/</id>
    <published>2019-06-27T02:46:47.000Z</published>
    <updated>2019-06-27T06:23:25.803Z</updated>
    
    <content type="html"><![CDATA[<p>本节讲述了如何配置 <code>.gitlab-ci.yml</code>，它为每个 <code>Runner</code> 的定制具体的任务。如果你想<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS9xdWlja19zdGFydC9SRUFETUUuaHRtbA==" title="http://docs.gitlab.com/ce/ci/quick_start/README.html">快速入手<i class="fa fa-external-link"></i></span></p>
<p>从 <code>GitLab 8.0</code> 开始，<code>GitLab CI</code> 就已经集成在 <code>GitLab</code> 中，我们只要在项目中添加一个 <code>.gitlab-ci.yml</code> 文件，然后添加一个 <code>Runner</code>，即可进行持续集成。 而且随着 <code>GitLab</code>的升级，<code>GitLab CI</code> 变得越来越强大，本文将介绍如何使用 <code>GitLab CI</code> 进行持续集成。</p>
<a id="more"></a>
<h3 id="全局配置"><a class="header-anchor" href="#全局配置">¶</a>全局配置</h3>
<p>从 <code>gitlab 7.12</code>，<code>gitlab ci</code> 使用 <strong>YAML</strong> 文件格式来作为项目的配置文件。</p>
<p><strong>.gitlab-ci.yml</strong> 定义了每一个 <code>runner</code> 运行的状态，环境以及运行方式，每一个运行任务都必须要定义一个 <code>script</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1_name:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2_name:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure>
<p>上面是一个简单的 <code>job</code> 示例，每个 <code>job</code> 可以定义不同的执行脚本或命令。<strong>不管是并行运行的任务，还是串行运行的任务，他们之间都是相互绝对独立的</strong>。</p>
<p><strong>.gitlab-ci.yml</strong> 一些保留字不能被用于作为 <code>Job</code> 的名字。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#image_or_services">image</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">使用 docker 镜像</td>
</tr>
<tr>
<td style="text-align:center"><a href="#image_or_services">services</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">使用 docker 服务</td>
</tr>
<tr>
<td style="text-align:center"><a href="#stages">stages</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义 build 级别</td>
</tr>
<tr>
<td style="text-align:center"><a href="#types">types</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">stages 的别名</td>
</tr>
<tr>
<td style="text-align:center"><a href="#before_script">before_script</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义每个 job 执行前执行的脚本</td>
</tr>
<tr>
<td style="text-align:center"><a href="#after_script">after_script</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义每个 job 执行后执行的脚本</td>
</tr>
<tr>
<td style="text-align:center"><a href="#variables">variables</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义全局环境变量</td>
</tr>
<tr>
<td style="text-align:center"><a href="#cache">cache</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义一些需要被缓存的文件</td>
</tr>
</tbody>
</table>
<p><span id="image_or_services"></span></p>
<h4 id="image-or-services"><a class="header-anchor" href="#image-or-services">¶</a>image or services</h4>
<p><code>image or services</code> 允许指定一个自定义的 docker 镜像或一系列的 docker 服务在执行 <code>build</code> 的时候，具体请<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS9kb2NrZXIvUkVBRE1FLmh0bWw=" title="http://docs.gitlab.com/ce/ci/docker/README.html">参考详情<i class="fa fa-external-link"></i></span></p>
<h4 id="stages"><a class="header-anchor" href="#stages">¶</a>stages</h4>
<p><code>stages</code> 用于定义一系列的 <em>build 级别</em>，这些 <em>级别</em> 用于 <code>job</code>中，定义的所有级别按照从前往后的顺序执行 <code>job</code>。</p>
<p>级别之间的运行顺序：</p>
<ul>
<li>相同 <em>级别</em> 的 <code>job</code> 都并行执行。</li>
<li>下一个级别的所有 <code>job</code> 都必须在上一个级别的所有 <code>job</code> 都 <code>build success</code> 的时候才能执行。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>
<p>不同级别的 <code>job</code> 运行示例:</p>
<p><img src="/uploads/images/posts/git/gitlab-ci/stages.png" alt="stages"></p>
<p>运行步骤：</p>
<ol>
<li>所有的 <code>build</code> 级别的 <em>job</em> 都并行执行。</li>
<li>当所有的 <code>build job</code> 都执行 <strong>成功</strong> 后，所有的 <code>test</code> 级别的 <em>job</em> 开始并行执行。</li>
<li>当所有的 <code>test job</code> 都执行 <strong>成功</strong> 后，所有的 <code>deploy</code> 级别的 <em>job</em> 开始并行执行。</li>
<li>当所有的 <code>deploy job</code> 都执行 <strong>成功</strong> 后，这个 <code>commit</code> 被标记为 <em>passed</em>。</li>
<li>如果其中任何一个 <em>job</em> 执行失败，这个 <code>commit</code> 被标记为 <em>failed</em>，并且跳出执行，以后的所有 <code>stage</code> 的 <em>job</em> 都不会在执行。</li>
</ol>
<p><strong>PS</strong>:</p>
<ul>
<li>假如 <em>.gitlab-ci.yml</em> 没有定义 <em>stages</em>，则默认顺序为 <code>build</code> -&gt; <code>test</code> -&gt; <code>deploy</code></li>
<li>假如 <em>job</em> 没有定义 <em>stage</em>，则默认该任务的 <code>stage</code> 为 ‘test’</li>
</ul>
<h4 id="types"><a class="header-anchor" href="#types">¶</a>types</h4>
<p><a href="#stages">stages</a> 的别名。</p>
<h4 id="before-script"><a class="header-anchor" href="#before-script">¶</a>before_script</h4>
<p><code>before_script</code> 定义了一系列命令，他们将会在每一个 <code>job</code> 之前运行，他可以是一个数组，也可以是一个多行的字符串。</p>
<h4 id="after-script"><a class="header-anchor" href="#after-script">¶</a>after_script</h4>
<p><code>before_script</code> 定义了一系列命令，他们将会在每一个 <code>job</code> 运行完成后执行，他可以是一个数组，也可以是一个多行的字符串。</p>
<h4 id="variables"><a class="header-anchor" href="#variables">¶</a>variables</h4>
<p><strong>Gitlab CI</strong> 允许你定一些变量，他们将会被复制到当前进程的环境变量中。他们能在之后运行的 <strong>脚本</strong> 或 <strong>命令行</strong> 中引用，<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS92YXJpYWJsZXMvUkVBRE1FLmh0bWw=" title="http://docs.gitlab.com/ce/ci/variables/README.html">预先定义的变量<i class="fa fa-external-link"></i></span>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">  DATABASE_URL:</span> <span class="string">"postgres://postgres@postgres/my_database"</span></span><br><span class="line"><span class="attr">  REDIS_URL:</span> <span class="string">"unix:/etc/redis/sockets/redis.socket"</span></span><br><span class="line"><span class="attr">  NODE_ENV:</span> <span class="string">"production"</span></span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>: 如果定义了 <em>Job</em> 级别的环境变量的话，该 <em>Job</em> 会优先使用 <em>Job</em> 级别的环境变量。</p>
<h4 id="cache"><a class="header-anchor" href="#cache">¶</a>cache</h4>
<p>定义需要缓存的文件。每个 <em>Job</em> 开始的时候，<code>Runner</code> 都会删掉 <code>.gitignore</code> 里面的文件。如果有些文件 (如 <code>node_modules/</code> ) 需要多个 <em>Jobs</em> 共用的话，我们只能让每个 <em>Job</em> 都先执行一遍 <code>npm install</code>。</p>
<p>这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 <em>Jobs</em> 使用外，还可以跨 <code>Pipeline</code> 使用。</p>
<p>具体用法请查看<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS95YW1sL1JFQURNRS5odG1sI2NhY2hl" title="http://docs.gitlab.com/ce/ci/yaml/README.html#cache">官方文档<i class="fa fa-external-link"></i></span>。</p>
<p><strong>PS</strong>：</p>
<ul>
<li>默认 <em>cache</em> 在每一个 <em>job</em> 和 <em>branch</em> 是开启的。</li>
<li>如果定义 <em>全局的 cache</em>，他表示每一个 <em>job</em> 都会使用该 <em>cache</em></li>
</ul>
<p>以下为具体示例：</p>
<ol>
<li>
<p>缓存 <code>binaries</code> 目录和 <code>.config</code> 文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.config</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缓存所有未跟踪（untracked）的文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job2:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缓存所有未跟踪（untracked）的文件和 <code>binaries</code> 目录。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job2:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    untracked:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>job</em> 级别的 <code>cache</code> 会重写 <code>全局 cahce</code>，下面示例只会缓存 <code>binaries</code> 目录。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">my/files</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="cache-key"><a class="header-anchor" href="#cache-key">¶</a>cache:key</h5>
<p><em>key</em> 字段允许你自由的定义 <code>cache</code> 的方式，是每个 <em>job</em> 都有一次缓存，还是 *所有 jobs * 只有一次 <code>cache</code>；它允许你在不同的 <em>job</em> 之间缓存数据；也允许你在不同的 <em>branch</em> 之间缓存数据。</p>
<ol>
<li>
<p>To enable per-job caching:</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"$CI_BUILD_NAME"</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>To enable per-branch caching:</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"$CI_BUILD_REF_NAME"</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>To enable per-job and per-branch caching:</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"$CI_BUILD_NAME/$CI_BUILD_REF_NAME"</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>To enable per-branch and per-stage caching:</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"$CI_BUILD_STAGE/$CI_BUILD_REF_NAME"</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>If you use Windows Batch to run your shell scripts you need to replace $ with %:</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"%CI_BUILD_STAGE%/%CI_BUILD_REF_NAME%"</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="job-配置"><a class="header-anchor" href="#job-配置">¶</a>Job 配置</h3>
<p><code>.gitlab-ci.yml</code> 允许你无限制的定义 <em>job</em>，每个 <em>job</em> 都必须要有一个 <strong>唯一</strong> 的名字，但不能是上面所提到的关键字，同时还提供了一些参数来制定你的 <em>job</em> 行为。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job_name:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">rake</span> <span class="string">spec</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">coverage</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">  allow_failure:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#script">script</a></td>
<td style="text-align:center">Required</td>
<td style="text-align:center">需要运行的脚本或命令</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_image_or_services">image</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">使用 <em>docker</em> 镜像</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_image_or_services">services</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">使用 <em>docker</em> 服务</td>
</tr>
<tr>
<td style="text-align:center"><a href="#stage">stage</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义 <em>build</em> 级别，默认 <em>test</em></td>
</tr>
<tr>
<td style="text-align:center"><a href="#type">type</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center"><em>stage</em> 的别名</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_variables">variables</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义 <em>job</em> 级别的环境变量</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_only_or_except">only</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定 <em>job</em> 哪些 <em>branch</em> 或 <em>tags</em> 是可以执行的</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_only_or_except">except</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定 <em>job</em> 哪些 <em>branch</em> 或 <em>tags</em> 是可以不可用执行的</td>
</tr>
<tr>
<td style="text-align:center"><a href="#tags">tags</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定执行 <em>job</em> 的 <code>runner</code></td>
</tr>
<tr>
<td style="text-align:center"><a href="#allow_failure">allow_failure</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定 <em>job</em> 允许失败</td>
</tr>
<tr>
<td style="text-align:center"><a href="#when">when</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义任务执行时间</td>
</tr>
<tr>
<td style="text-align:center"><a href="#artifacts">artifacts</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定需要上传到 <code>Gitlab</code> 的文件</td>
</tr>
<tr>
<td style="text-align:center"><a href="#dependencies">dependencies</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义需要下载的 <code>artifacts</code></td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_cache">cache</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义一些需要被缓存的文件</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_before_script">before_script</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定 <em>job</em> 执行前运行的脚本或命令</td>
</tr>
<tr>
<td style="text-align:center"><a href="#job_after_script">after_script</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">指定 <em>job</em> 执行完成后运行的脚本或命令</td>
</tr>
<tr>
<td style="text-align:center"><a href="#environment">environment</a></td>
<td style="text-align:center">no</td>
<td style="text-align:center">定义发布到指定的 environment 中</td>
</tr>
</tbody>
</table>
<h4 id="script"><a class="header-anchor" href="#script">¶</a>script</h4>
<p><code>Runner</code> 运行的所需的脚本，他可以是 <strong>字符串</strong> 或 <strong>数组</strong>，如下：</p>
<p>如果只运行一条命令时，可以选择字符串：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span> <span class="string">"npm run build"</span></span><br></pre></td></tr></table></figure>
<p>如果要运行多行命令，可以选择数组：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">uname</span> <span class="bullet">-a</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>
<p><span id="job_image_or_services"></span></p>
<h4 id="image-or-services-v2"><a class="header-anchor" href="#image-or-services-v2">¶</a>image or services</h4>
<p><code>image or services</code> 允许指定一个自定义的 docker 镜像或一系列的 docker 服务在执行 <code>build</code> 的时候，具体请<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS9kb2NrZXIvUkVBRE1FLmh0bWw=" title="http://docs.gitlab.com/ce/ci/docker/README.html">参考详情<i class="fa fa-external-link"></i></span>。</p>
<p><strong>PS</strong>：如果该值存在，在这个 <em>job</em> 中使用该值，否则使用全局定义的 <strong>image &amp; services</strong></p>
<h4 id="stage"><a class="header-anchor" href="#stage">¶</a>stage</h4>
<p>指定当前 <em>job</em> 的级别，相同级别的 <em>job</em> 是并行执行的，详情参考 <a href="#stages">stages</a>。</p>
<h4 id="type"><a class="header-anchor" href="#type">¶</a>type</h4>
<p><a href="#stage">stage</a> 的别名。</p>
<p><span id="job_variables"></span></p>
<h4 id="variables-v2"><a class="header-anchor" href="#variables-v2">¶</a>variables</h4>
<p><em>job 级别</em> 的变量，一旦定义了 <em>job 级别</em> 的变量，它所定义的变量将优先于 <a href="#variables">YAML 中定义的全局变量</a> 和 <span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS92YXJpYWJsZXMvUkVBRE1FLmh0bWw=" title="http://docs.gitlab.com/ce/ci/variables/README.html">预定义变量<i class="fa fa-external-link"></i></span>。</p>
<p>变量的优先级<span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS92YXJpYWJsZXMvUkVBRE1FLmh0bWw=" title="http://docs.gitlab.com/ce/ci/variables/README.html">参考这里<i class="fa fa-external-link"></i></span></p>
<p><span id="job_only_or_except"></span></p>
<h4 id="only-or-except"><a class="header-anchor" href="#only-or-except">¶</a>only or except</h4>
<p><em>only</em> 或 <em>except</em> 参数可以指定一套规则来限制 <em>job</em> 是否需要执行。</p>
<ul>
<li>可以通过配置 <em>only</em> 来指定哪些 <em>branch</em> 或 <em>tag</em> 是 <strong>需要</strong> 执行 <em>job</em>。</li>
<li>可以通过配置 <em>only</em> 来指定哪些 <em>branch</em> 或 <em>tag</em> 是 <strong>不需要</strong> 执行 <em>job</em>。</li>
</ul>
<p>参数规则：</p>
<ul>
<li><em>only</em> 和 <em>except</em> 会同时生效，如果同时指定了 <em>only</em> 和 <em>except</em>，他们都会生效。</li>
<li><em>only</em> 和 <em>except</em> 都支持正则表达式。</li>
<li><em>only</em> 和 <em>except</em> 都可以使用特殊关键字：<code>branches</code>、<code>tags</code> 和 <code>triggers</code> 。</li>
<li><em>only</em> 和 <em>except</em> 可以根据仓库地址来过滤，一般用户 <code>fork</code> 工作流。</li>
</ul>
<p>示例：</p>
<ol>
<li><code>only</code> 规定了所有符合 <code>/^issue\-.*$/</code> 的 <em>branch</em> 或 <em>tag</em> 都可以执行，<em>except</em> 规定了所有的 <em>branch</em> 都不执行，所以最终只执行了 <strong>所有符合正则表达式的 tag</strong>。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use regexp</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/^issue-.*$/</span></span><br><span class="line">  <span class="comment"># use special keyword</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">branches</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>只有 <em>tags</em> 和 <em>triggers</em> 执行。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use special keywords</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">triggers</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><em>job</em> 只执行父仓库，不执行 <code>fork</code> 的仓库，即：只执行 <code>gitlab-org/gitlab-ce</code> 上的 <em>branches</em> 且不执行 <code>master</code> 分支。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">branches@gitlab-org/gitlab-ce</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master@gitlab-org/gitlab-ce</span></span><br></pre></td></tr></table></figure>
<h4 id="tags"><a class="header-anchor" href="#tags">¶</a>tags</h4>
<p><em>tags</em> 用来指定特殊的 <code>Runner</code> 来运行这个 <em>job</em>。</p>
<p><em>tags</em> 的过滤方式是通过 <strong>runner</strong> 在注册的时候会指定该 <em>runner</em> 的 <code>tag</code>。</p>
<p>示例：下面是一个 <em>tag</em> 为 <code>shell</code> 的 <strong>runner</strong>。</p>
<p><img src="https://rs.daniujia.com/chatserver/images/docs/git/ci/job_tags.png" alt="job_tags"></p>
<p>我们某一个 <strong>job</strong> 指定一个 <em>runner</em> 来运行这个 <em>job</em>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">shell</span></span><br></pre></td></tr></table></figure>
<h4 id="allow-failure"><a class="header-anchor" href="#allow-failure">¶</a>allow_failure</h4>
<p>当 <em>job</em> 运行失败或出现警告的时候，则依然认为该 <em>job</em> 是 <strong>成功</strong> 的，但是这个 <code>build</code> 详情里面能够看到相关的错误信息与警告信息。</p>
<h4 id="when"><a class="header-anchor" href="#when">¶</a>when</h4>
<p>该参数指定 <em>job</em> 执行的条件，参数值可以取：</p>
<ul>
<li><code>on_success</code>：只有之前的所有 <em>job</em> 都执行成功了，才执行这个 <em>job</em>，<strong>默认</strong>。</li>
<li><code>on_failure</code>：只要之前的所有 <em>job</em> 中有一个执行失败了，就执行这个 <em>job</em>。</li>
<li><code>always</code>：不管之前的所有 <em>job</em> 执行状态是什么，都执行这个 <em>job</em>。</li>
<li><code>manual</code>：手动执行，请参考 <span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS95YW1sL1JFQURNRS5odG1sI21hbnVhbC1hY3Rpb25z" title="http://docs.gitlab.com/ce/ci/yaml/README.html#manual-actions">manual actions<i class="fa fa-external-link"></i></span>。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cleanup_build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cleanup</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_build_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">cleanup_build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cleanup</span> <span class="string">build</span> <span class="string">when</span> <span class="string">failed</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">on_failure</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">manual</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">cleanup</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cleanup</span> <span class="string">after</span> <span class="string">builds</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>上面的执行情况为：</p>
<ul>
<li>当 <code>build_job</code> 执行失败，就会执行 <code>cleanup_build_job</code>，否则不执行。</li>
<li>无论如何 <code>cleanup_job</code> 都会作为最后一个 <em>job</em> 执行。</li>
<li>允许你从 <strong>Gitlab UI</strong> 中手动执行 <code>deploy_job</code>。</li>
</ul>
<p><strong>PS</strong>: <code>manual</code> 是一种特殊的类型，他类型阻止 <em>job</em> 自动运行，需要用户手动点击执行。</p>
<h4 id="artifacts"><a class="header-anchor" href="#artifacts">¶</a>artifacts</h4>
<p>定义 <code>Job</code> 中生成的附件。当该 <code>Job</code> 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 <code>GitLab</code>，之后我们可以在 <code>GitLab</code> 的项目页面下下载该附件。</p>
<p><strong>注意</strong>：不要把 <code>artifacts</code> 和 <code>cache</code> 混淆了。</p>
<p>下面是一些具体示例：</p>
<ol>
<li>
<p>发送所有位于 <code>binaries</code> 目录下的文件和 <code>.config</code> 文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">binaries/</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.config</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>发送所有 <strong>未跟踪</strong> 的文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>发送所有位于 <code>binaries</code> 目录下的 <strong>未跟踪</strong> 文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当 <code>tag</code> 的时候，发送所有 <code>binaries</code> 目录下的文件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">release-job:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mvn</span> <span class="string">package</span> <span class="bullet">-U</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">target/*.war</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>发送所有 <code>binaries</code> 目录下的文件，并指定发送文件的名字。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line">    <span class="comment"># 指定 name：job_name.current_branch_or_tag_name</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"$&#123;CI_BUILD_NAME&#125;.$&#123;CI_BUILD_REF_NAME&#125;"</span></span><br><span class="line"><span class="attr">    untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定发送文件的条件。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">on_failure</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>when</strong> 的取值有：</p>
<ul>
<li><code>on_success</code>：当 <em>job</em> 执行成功，就发送文件。</li>
<li><code>on_failure</code>：当 <em>job</em> 执行失败，就发送文件。</li>
<li><code>always</code>：无论 <em>job</em> 执行成功或者失败，都发送文件。</li>
</ul>
<ol start="7">
<li>指定发送文件的 <strong>生存期</strong>。</li>
</ol>
<p><strong>expire_in</strong> 是指该文件能够保存的时长，比如：</p>
<ul>
<li>
<p>‘3 mins 4 sec’</p>
</li>
<li>
<p>‘2 hrs 20 min’</p>
</li>
<li>
<p>‘2h20min’</p>
</li>
<li>
<p>‘6 mos 1 day’</p>
</li>
<li>
<p>‘47 yrs 6 mos and 4d’</p>
</li>
<li>
<p>‘3 weeks and 2 days’</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="dependencies"><a class="header-anchor" href="#dependencies">¶</a>dependencies</h4>
<p>该参数用于与<a href="#artifacts">artifacts</a>结合使用，允许你指定不同 <em>job</em> 之间 <em>artifacts</em>，的传输。</p>
<p><strong>PS</strong>：默认后面的 <em>job</em> 将会下载前面所有 <em>job</em> 所上传的文件。</p>
<p>通过这个参数，能够有效的为每一个 <em>job</em> 定义他所需要下载的 <em>artifacts</em>，该参数的值 <strong>必须</strong> 为前面所定义好的 <em>job</em> 的名字（<code>按照 stages 定义的顺序来判断</code>），如果 <code>dependencies</code> 的值，在 <code>stages</code> 定义的顺序中，如果 <em>job</em> 的 <code>dependencies</code> 的值指向了一个前面没有定义过的 <em>job</em> 的名字则将会抛出错误。<code>dependencies</code> 指定 <strong>空数组</strong>则不会下载任何前面上传的 <em>artifacts</em>。</p>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span><span class="attr">osx:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">build:osx</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span><span class="attr">linux:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">build:linux</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">osx:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">test:osx</span></span><br><span class="line"><span class="attr">  dependencies:</span></span><br><span class="line"><span class="attr">    - build:</span><span class="string">osx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">linux:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">test:linux</span></span><br><span class="line"><span class="attr">  dependencies:</span></span><br><span class="line"><span class="attr">    - build:</span><span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>
<p>在该示例中：</p>
<ul>
<li><code>test:osx</code> 在 <code>script</code> 执行前下载 <code>build:osx</code> 上传的 <em>artifacts</em>。</li>
<li><code>test:linux</code> 在 <code>script</code> 执行前下载 <code>build:linux</code> 上传的 <em>artifacts</em>。</li>
<li><code>deploy</code> 在 <code>script</code> 执行前下载 <code>build:osx</code> 和 <code>build:linux</code> 上传的 <em>artifacts</em>。</li>
</ul>
<p><span id="job_cache"></span></p>
<h4 id="cache-v2"><a class="header-anchor" href="#cache-v2">¶</a>cache</h4>
<p>该参数在当前 <em>job</em> 中将会重写 <a href="#cache">全局的 cache</a>。</p>
<p><span id="job_before_script"></span></p>
<h4 id="before-script-v2"><a class="header-anchor" href="#before-script-v2">¶</a>before_script</h4>
<p>该参数在当前 <em>job</em> 中将会重写 <a href="#before_script">全局的 before_script</a>。</p>
<p><span id="job_after_script"></span></p>
<h4 id="after-script-v2"><a class="header-anchor" href="#after-script-v2">¶</a>after_script</h4>
<p>该参数在当前 <em>job</em> 中将会重写 <a href="#after_script">全局的 after_script</a>。</p>
<h4 id="environment"><a class="header-anchor" href="#environment">¶</a>environment</h4>
<p>该值用来指定发布（deploy）的时候指定到一个特殊的 <code>environment</code> 中，这个将会非常有利于在 <code>Gitlab</code> 中追踪整个发布过程。</p>
<p><strong>PS</strong>：<em>environment</em> 的值只能包含 <strong>字母</strong>、<strong>数字</strong>、<strong>-</strong> 和 <strong>_</strong> 组成。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy_to_production:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="attr">HEAD:master</span></span><br><span class="line"><span class="attr">  environment:</span> <span class="string">production</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">install_deps</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy_test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy_production</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">$&#123;CI_BUILD_REF_NAME&#125;</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">dist/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="attr">install_deps:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">install_deps</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试用例</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="attr">build:client</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="attr">build:server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署测试服务器</span></span><br><span class="line"><span class="attr">deploy_test:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy_test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pm2</span> <span class="string">delete</span> <span class="string">app</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pm2</span> <span class="string">start</span> <span class="string">app.js</span> <span class="bullet">--name</span> <span class="string">app</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署生产服务器</span></span><br><span class="line"><span class="attr">deploy_production:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy_production</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bash</span> <span class="string">scripts/deploy/deploy.sh</span></span><br></pre></td></tr></table></figure>
<p>上面的配置把一次 Pipeline 分成五个阶段：</p>
<ol>
<li>安装依赖(<code>install_deps</code>)</li>
<li>运行测试(<code>test</code>)</li>
<li>编译(<code>build</code>)</li>
<li>部署测试服务器(<code>deploy_test</code>)</li>
<li>部署生产服务器(<code>deploy_production</code>)</li>
</ol>
<p>设置 <code>Job.only</code> 后，只有当 <code>develop</code> 分支和 <code>master</code> 分支有提交的时候才会触发相关的 <code>Jobs</code>。<br>
注意，我这里用 <strong>GitLab Runner</strong> 所在的服务器作为测试服务器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节讲述了如何配置 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt;，它为每个 &lt;code&gt;Runner&lt;/code&gt; 的定制具体的任务。如果你想&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS9xdWlja19zdGFydC9SRUFETUUuaHRtbA==&quot; title=&quot;http://docs.gitlab.com/ce/ci/quick_start/README.html&quot;&gt;快速入手&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;GitLab 8.0&lt;/code&gt; 开始，&lt;code&gt;GitLab CI&lt;/code&gt; 就已经集成在 &lt;code&gt;GitLab&lt;/code&gt; 中，我们只要在项目中添加一个 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件，然后添加一个 &lt;code&gt;Runner&lt;/code&gt;，即可进行持续集成。 而且随着 &lt;code&gt;GitLab&lt;/code&gt;的升级，&lt;code&gt;GitLab CI&lt;/code&gt; 变得越来越强大，本文将介绍如何使用 &lt;code&gt;GitLab CI&lt;/code&gt; 进行持续集成。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.charleslxh.top/categories/git/"/>
    
    
      <category term="Git" scheme="http://blog.charleslxh.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git 工作流程</title>
    <link href="http://blog.charleslxh.top/2019/06/26/2019/git-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://blog.charleslxh.top/2019/06/26/2019/git-工作流程/</id>
    <published>2019-06-26T02:45:37.000Z</published>
    <updated>2019-06-27T06:20:57.931Z</updated>
    
    <content type="html"><![CDATA[<p>有一套 <strong>规范</strong>、<strong>严谨</strong> 的开发流程是一个团队提高工作效率，减少工作冲突的重要途径，以下使我们公司目前使用的开发流程，请大家 <strong>务必严格</strong> 遵循该流程。</p>
<a id="more"></a>
<h2 id="流程说明"><a class="header-anchor" href="#流程说明">¶</a>流程说明</h2>
<p><img src="/uploads/images/posts/git/git-flow/git-flow.png" alt="git-flow"></p>
<h2 id="分支概述"><a class="header-anchor" href="#分支概述">¶</a>分支概述</h2>
<p>从上图，我们可以大概清楚整个开发流程，大概了解各个开发分支的作用与关系，下面我们将详细概述他们。</p>
<p><code>Git</code> 分支一般分为两种：<strong>长期支持分支</strong>，<strong>短期支持分支</strong>。<em>长期支持</em> 的分支是受保护的，长期维护、迭代和更新的，是不能被删除的；<em>短期支持</em> 分支一般是用于实现某个新功能、修复长期支持分支上的问题而产生的，他们都是基于长期分支的小分支，在它们的使命完成后都需要被删除。</p>
<p>长期支持的分支有：</p>
<ul>
<li><code>master</code>：主分支，负责记录上线版本的迭代，该分支代码与线上代码是完全一致的。</li>
<li><code>develop</code>：开发分支，该分支记录相对稳定的版本，所有的 <code>feature</code> 分支和 <code>bugfix</code> 分支都从该分支创建。</li>
</ul>
<p>短期支持分支有：</p>
<ul>
<li><code>feature/*</code>：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 <code>develop</code> 分支，之后删除该分支。</li>
<li><code>bugfix/*</code>：<code>bug</code> 修复分支，用于修复不紧急的 <code>bug</code>，普通 <code>bug</code> 均需要创建 <code>bugfix</code> 分支开发，开发完成自测没问题后合并到 <code>develop</code> 分支后，删除该分支。</li>
<li><code>release/*</code>：发布分支，用于代码上线准备，该分支从 <code>develop</code> 分支创建，创建之后由测试同学发布到测试环境进行测试，测试过程中发现 <code>bug</code> 需要开发人员在该release分支上进行bug修复，所有bug修复完后，在上线之前，需要合并该 <code>release</code> 分支到 <code>master</code> 分支和 <code>develop</code> 分支。</li>
<li><code>hotfix/*</code>：紧急 <code>bug</code> 修复分支，该分支只有在紧急情况下使用，从 <code>master</code> 分支创建，用于紧急修复线上 <code>bug</code>，修复完成后，需要合并该分支到 <code>master</code> 分支以便上线，同时需要再合并到 <code>develop</code> 分支。</li>
</ul>
<h3 id="长期支持分支"><a class="header-anchor" href="#长期支持分支">¶</a>长期支持分支</h3>
<p><img src="/uploads/images/posts/git/git-flow/main-branches@2x.png" alt="git-flow"></p>
<h4 id="master"><a class="header-anchor" href="#master">¶</a>master</h4>
<p><strong>一切源于 <code>master</code></strong>。</p>
<p>一个丰富、复杂的代码仓库都是以 <code>master</code> 分支开始的，相信 <code>git</code> 用户都会非常了解这个分支，没错它就是我们的主分支，他的代码与线上的代码一模一样（这点，每个项目管理员都必须保证），所以他是稳定的、干净的、经过严格测试过的。</p>
<h4 id="develop"><a class="header-anchor" href="#develop">¶</a>develop</h4>
<p><code>develop</code> 一开始是从 <code>master</code> 切出来复制版，它永远跑在 <code>master</code> 的前面，它包含了一切未来即将上线的功能。</p>
<p>所有 <strong>新功能</strong> 都是基于 <code>develop</code> 分支做开发，当然，部分小的修改可以直接在这个分支上提交代码，但提交者必须明确自己在做什么，必须对自己严谨，一般不推荐。</p>
<h3 id="短期支持分支"><a class="header-anchor" href="#短期支持分支">¶</a>短期支持分支</h3>
<p>在主分支（长期支持分支）之后，我们使用了大量的短期分支，通过这些短期分支来协助开发，充分的利用 <code>git</code> 分支的特性，使每个分支的功能更加 <em>明确</em> 与 <em>简单</em> ，不同于长期分支，这些分支都有一个较短的生命周期。</p>
<p>任何短期分支都有一个明确的目的，并且必须遵守严格的规则。</p>
<blockquote>
<p>我们都必须遵循：所有的短期分支功能必须做到单一、明确，而不应该出现过于复杂的业务逻辑，更不应该跨业务。</p>
</blockquote>
<h4 id="feature"><a class="header-anchor" href="#feature">¶</a>Feature</h4>
<p><code>Feature</code> 分支用于开发新功能，俗称 <strong>功能分支</strong>，该分支完成后将会合并入 <code>develop</code> 分支，并删除。</p>
<p>该分支 <strong>必须</strong> 基于 <code>develop</code> ，分支功能完成后 <strong>必须</strong> 合并到 <code>develop</code>。</p>
<p><strong>命名规范：除了 <code>master</code>、<code>develop</code>、<code>release-*</code>、<code>bugfix-*</code> 或 <code>hotfix-*</code> 之外的任何东西，最好名字能概括分支的功能，但不宜过长。</strong></p>
<p><img src="/uploads/images/posts/git/git-flow/fb@2x.png" alt="git-flow"></p>
<h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5>
<ol>
<li>创建一个新功能分支。</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -t origin/develop -b myfeature</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Switched to a new branch <span class="string">"myfeature"</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>提交更新。</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'Your commit message here.'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin myfeature -f</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br>
- 一个分支一条 <code>commit</code>，如果后续有更新，请使用 <code>git commit --amend</code> 提交更改。<br>
- <code>push</code> 代码前 <strong>必须</strong> 拉取远程最新代码，以防止其他人与产生冲突。</p>
<ol start="3">
<li>功能完成，将该分支合并到 <code>develop</code> 分支。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"><span class="comment"># Switched to branch 'develop'</span></span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line"><span class="comment"># Updating ea1b82a..05e9557</span></span><br><span class="line"><span class="comment"># (Summary of changes)</span></span><br><span class="line">$ git branch -d myfeature</span><br><span class="line"><span class="comment"># Deleted branch myfeature (was 05e9557).</span></span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure>
<p><code>--no-ff</code> 选项为强制关闭 <code>Fast-Forward</code> 模式，即每次合并都会产生一个 <code>commit</code>，需要用户指定 <code>message</code> 内容，该操作可以避免丢失部分信息。</p>
<p><code>fast-forward</code> 方式就是当条件允许的时候，<code>git</code> 直接把 <code>HEAD</code> 指针指向合并分支的头，完成合并。属于 <strong>快进方式</strong>，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建 <code>commit</code>。</p>
<p><img src="/uploads/images/posts/git/git-flow/merge-without-ff@2x.png" alt="git-flow"></p>
<ol start="4">
<li>功能分支完成使命，删除。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D myfeature</span><br><span class="line"><span class="comment"># Deleted branch myfeature (was ff452fe).</span></span><br><span class="line">$ git push origin :myfeature</span><br><span class="line"><span class="comment"># To git@git.domain.com:group/project_name.git</span></span><br><span class="line"><span class="comment">#   - [deleted]         myfeature</span></span><br></pre></td></tr></table></figure>
<h4 id="release"><a class="header-anchor" href="#release">¶</a>Release</h4>
<p><code>Release</code> 分支用于准备即将上线的内容，此外，该分支可以对 <strong>版本号</strong>、<strong>构建日期</strong> 进行更改。通过 <strong>发布分支</strong> 来完成这些事情，<code>develop</code> 分支就继续接受下一次需要发布的功能、<code>Bug</code> 修复等等，从而不需要等待 <code>master</code> 发布完成后。</p>
<p>该分支 <strong>必须</strong> 基于 <code>develop</code> ，分支功能完成后 <strong>必须</strong> 合并到 <code>develop</code> 和 <code>master</code>。</p>
<p><strong>命名规范：<code>release-*</code></strong>。</p>
<h5 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h5>
<p>例如：目前正式环境的版本为 <code>1.1.5</code>，而此时有两个功能分支 <code>feature/A</code> 和 <code>feature/B</code>，其中 <code>feature/A</code> 是本次需要部署到正式环境的内容，版本号为 <code>1.2.0</code>。而 <code>feature/B</code> 是准备在 <code>1.3.0</code> 中发布的新功能。所以，我们需要先将 <code>feature/A</code> 合并到 <code>develop</code> 分支，然后基于当前 <code>develop</code> 分支中创建一个 <code>release-1.2</code> 分支，这样 <code>develop</code> 就被释放了，他可以继续接受其他的新功能了，等待下一次发布。</p>
<ol>
<li>创建发布分支。</li>
</ol>
<p>发布分支是从 <code>develop</code> 分支创建的，创建的时候 <strong>务必</strong> 确保当前 <code>develop</code> 的所有功能都是本次上线的功能，并且是经过测试的，下一次上线的功能需要在发布分支创建之后再合并入 <code>develop</code>。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t origin/develop -b release-1.2.0</span><br><span class="line"><span class="comment"># Switched to a new branch "release-1.2.0"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>更新元信息：版本好、构建时间等等。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./bump-version.sh 1.2.0</span><br><span class="line"><span class="comment"># Files modified successfully, version bumped to 1.2.0.</span></span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2.0"</span></span><br><span class="line"><span class="comment"># [release-1.2.0 74d9424] Bumped version number to 1.2.0</span></span><br><span class="line"><span class="comment">#   1 files changed, 1 insertions(+), 1 deletions(-)</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>合并到 <code>master</code>。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># Switched to branch 'master'</span></span><br><span class="line">$ git merge --no-ff release-1.2.0</span><br><span class="line"><span class="comment"># Merge made by recursive.</span></span><br><span class="line"><span class="comment"># (Summary of changes)</span></span><br><span class="line">$ git push origin master</span><br><span class="line">$ git tag -a 1.2.0</span><br><span class="line">$ git push origin 1.2.0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>合并到 <code>develop</code>。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"><span class="comment"># Switched to branch 'develop'</span></span><br><span class="line">$ git merge --no-ff release-1.2.0</span><br><span class="line"><span class="comment"># Merge made by recursive.</span></span><br><span class="line"><span class="comment"># (Summary of changes)</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>删除发布分支。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D release-1.2.0</span><br><span class="line"><span class="comment"># Deleted branch release-1.2.0 (was ff452fe).</span></span><br></pre></td></tr></table></figure>
<h4 id="hotfix"><a class="header-anchor" href="#hotfix">¶</a>Hotfix</h4>
<p><code>Hotfix</code> 分支跟 <code>Release</code> 分支差不多，都是为了准备下一次上线内容，不过他用于处理 <strong>紧急的</strong> 的线上环境的 <code>Bug</code>，<code>Hotfix</code> 分支必须从 <code>master</code> 分支创建。</p>
<p><code>Hotfix</code> 分支的本质作用为：当一个人紧急修复正式环境某个 <code>Bug</code> 时不会影响其他开发人员（<code>develop</code> 分支）的工作进度。</p>
<p>该分支 <strong>必须</strong> 基于 <code>master</code> ，分支功能完成后 <strong>必须</strong> 合并到 <code>develop</code> 和 <code>master</code> 。</p>
<p><strong>命名规范：<code>hotfix-*</code></strong>。</p>
<p><img src="/uploads/images/posts/git/git-flow/hotfix-branches@2x.png" alt="git-flow"></p>
<h5 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h5>
<p>例如：目前正式环境的版本为 <code>1.2.0</code>，但是，发现线上有一些 <code>Bug</code>，需要紧急修复，但是 <code>develop</code> 分支上的新功能还不稳定，不能发布，所以我们需要使用 <code>hotfix</code> 分支来修复线上 <code>Bug</code>。</p>
<ol>
<li>创建 <code>hotfix</code> 分支。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t origin/master -b hotfix-1.2.1</span><br><span class="line">Switched to a new branch <span class="string">"hotfix-1.2.1"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修复 <code>Bug</code> 之后，提交更改。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line"><span class="comment"># [hotfix-1.2.1 abbe5d6] Fixed severe production problem</span></span><br><span class="line"><span class="comment">#   5 files changed, 32 insertions(+), 17 deletions(-)</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提升版本号，然后提交。</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line"><span class="comment"># Files modified successfully, version bumped to 1.2.1.</span></span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line"><span class="comment"># [hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span></span><br><span class="line"><span class="comment">#   1 files changed, 1 insertions(+), 1 deletions(-)</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>合并到 <code>master</code>。</li>
</ol>
<p>将修复过的程序发布到正式环境。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># Switched to branch 'master'</span></span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line"><span class="comment"># Merge made by recursive.</span></span><br><span class="line"><span class="comment"># (Summary of changes)</span></span><br><span class="line">$ git push origin master</span><br><span class="line">$ git tag -a 1.2.1</span><br><span class="line">$ git push origin 1.2.1</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>合并到 <code>develop</code>。</li>
</ol>
<p>为了确保下一次发布包含该修复的问题，我们需要将该 <code>hotfix</code> 分支合并入 <code>develop</code> 分支。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"><span class="comment"># Switched to branch 'develop'</span></span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line"><span class="comment"># Merge made by recursive.</span></span><br><span class="line"><span class="comment"># (Summary of changes)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果有 <code>未发布</code> 的 <strong>发布分支</strong> 存在，则需要将该 <code>hotfix</code> 分支合并入 <strong>发布分支</strong>，而不是 <code>develop</code> 分支，因为最终发布分支也会被合并到 <code>develop</code> 分支，如果 <code>develop</code> 非常紧急的需要使用 <code>hotfix</code> 上修复的内容，也可以合并到 <code>develop</code> 分支，这都不会有影响。</p>
<ol start="6">
<li>删除该分支。</li>
</ol>
<p>该功能分支使命结束后，删除它。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line"><span class="comment"># Deleted branch hotfix-1.2.1 (was abbe5d6).</span></span><br></pre></td></tr></table></figure>
<h3 id="版本标记"><a class="header-anchor" href="#版本标记">¶</a>版本标记</h3>
<p>同大多数 <code>VCS</code> 一样，<code>Git</code> 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 <code>v1.0</code> 等等）的时候，经常这么做。</p>
<p><code>Git</code> 使用的标签有两种类型：</p>
<ul>
<li>轻量级的（lightweight）：轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</li>
<li>含附注的（annotated）：含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 <code>GNU Privacy Guard (GPG)</code> 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；</li>
</ul>
<p>当然，如果只是临时性加注标签，或者不需要旁注额外信息，用 <em>轻量级标签</em> 也没问题。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YxL0dpdC0lRTUlOUYlQkElRTclQTElODAtJUU2JTg5JTkzJUU2JUEwJTg3JUU3JUFEJUJF" title="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE">详情查看 - 如何打标签？<i class="fa fa-external-link"></i></span></p>
<h2 id="使用-git-flow-简化操作"><a class="header-anchor" href="#使用-git-flow-简化操作">¶</a>使用 git flow 简化操作</h2>
<p><code>git flow</code> 是 <code>git</code> 的一个插件，可以极大程度的简化执行 <code>git</code> 标准分支流程的操作，可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGVydmFuZGVyZG9lcy9naXRmbG93LWF2aA==" title="https://github.com/petervanderdoes/gitflow-avh">gitflow-avh<i class="fa fa-external-link"></i></span> 安装。</p>
<p>详情参考： <a href="/docs/knowledges/git/tools#git-flow">Git 相关工具介绍 - Git flow</a>。</p>
<h2 id="特别鸣谢"><a class="header-anchor" href="#特别鸣谢">¶</a>特别鸣谢</h2>
<ul>
<li><span class="exturl" data-url="aHR0cDovL252aWUuY29tL3Bvc3RzL2Etc3VjY2Vzc2Z1bC1naXQtYnJhbmNoaW5nLW1vZGVsLw==" title="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model<i class="fa fa-external-link"></i></span> - <span class="exturl" data-url="aHR0cDovL252aWUuY29tL2Fib3V0Lw==" title="http://nvie.com/about/">Vincent Driessen<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215bHhzdy9ncm93aW5nLXVwL2Jsb2IvbWFzdGVyL2RvYy8lRTclQTAlOTQlRTUlOEYlOTElRTUlOUIlQTIlRTklOTglOUZHSVQlRTUlQkMlODAlRTUlOEYlOTElRTYlQjUlODElRTclQTglOEIlRTYlOTYlQjAlRTQlQkElQkElRTUlQUQlQTYlRTQlQjklQTAlRTYlOEMlODclRTUlOEQlOTcubWQ=" title="https://github.com/mylxsw/growing-up/blob/master/doc/%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9FGIT%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%96%B0%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97.md">研发团队GIT开发流程新人学习指南<i class="fa fa-external-link"></i></span> - <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215bHhzdw==" title="https://github.com/mylxsw">管宜尧<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YxL0dpdC0lRTUlODglODYlRTYlOTQlQUYtJUU1JTg4JUE5JUU3JTk0JUE4JUU1JTg4JTg2JUU2JTk0JUFGJUU4JUJGJTlCJUU4JUExJThDJUU1JUJDJTgwJUU1JThGJTkxJUU3JTlBJTg0JUU1JUI3JUE1JUU0JUJEJTlDJUU2JUI1JTgxJUU3JUE4JThC" title="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%A9%E7%94%A8%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Git 分支 - 利用分支进行开发的工作流程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDcvZ2l0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略<i class="fa fa-external-link"></i></span> - <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS8=" title="http://www.ruanyifeng.com/">阮一峰<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一套 &lt;strong&gt;规范&lt;/strong&gt;、&lt;strong&gt;严谨&lt;/strong&gt; 的开发流程是一个团队提高工作效率，减少工作冲突的重要途径，以下使我们公司目前使用的开发流程，请大家 &lt;strong&gt;务必严格&lt;/strong&gt; 遵循该流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.charleslxh.top/categories/git/"/>
    
    
      <category term="Git" scheme="http://blog.charleslxh.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git-基本知识</title>
    <link href="http://blog.charleslxh.top/2019/06/25/2019/git-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.charleslxh.top/2019/06/25/2019/git-基本知识/</id>
    <published>2019-06-25T02:46:26.000Z</published>
    <updated>2019-06-27T06:20:39.810Z</updated>
    
    <content type="html"><![CDATA[<p>这篇指南以大家在<code>SVN</code>中已经广为熟悉使用的集中式工作流作为起点，循序渐进地演进到其它高效的分布式工作流，还介绍了如何配合使用便利的<code>Pull Request</code>功能，体系地讲解了各种工作流的应用。<br>
如果你<code>Git</code>用的还不多，可以从前面的讲的工作流开始操练。操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。</p>
<p><strong>GIT</strong> 是目前主流的<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFOCVCNSVCNyVFNiVBRCVBNS0lRTUlODUlQjMlRTQlQkElOEUlRTclODklODglRTYlOUMlQUMlRTYlOEUlQTclRTUlODglQjYjJUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU3JTg5JTg4JUU2JTlDJUFDJUU2JThFJUE3JUU1JTg4JUI2JUU3JUIzJUJCJUU3JUJCJTlG" title="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F">分布式版本控制系统<i class="fa fa-external-link"></i></span>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLw==" title="https://git-scm.com/book/zh/v2/">GIT 详细文档点击这里<i class="fa fa-external-link"></i></span></p>
<a id="more"></a>
<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>行文中实践原则和操作示例并重，对于<code>Git</code>的资深玩家可以梳理思考提升，而新接触的同学，也可以跟着step-by-step操练学习并在实际工作中上手使用。</p>
<p>工作流其实不是一个初级主题，背后的本质问题其实是 有效的项目流程管理 和 高效的开发协同约定，而不仅是<code>Git</code>或<code>SVN</code>等<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTclODklODglRTYlOUMlQUMlRTYlOEUlQTclRTUlODglQjY=" title="http://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><code>VCS</code><i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTglQkQlQUYlRTQlQkIlQjYlRTklODUlOEQlRTclQkQlQUUlRTclQUUlQTElRTclOTAlODY=" title="http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><code>SCM</code><i class="fa fa-external-link"></i></span>工具的使用。</p>
<p>关于<code>Git</code>工作流主题，网上体系的中文资料不多，主要是零散的操作说明，希望这篇文章能让你更深入理解并在工作中灵活有效地使用起来。</p>
<p><code>Gitflow</code>工作流是经典模型，处于核心位置，体现了工作流的经验和精髓。随着项目过程复杂化，你会感受到这个工作流中的深思熟虑和威力！</p>
<p><code>Forking</code>工作流是分布式协作的（<code>GitHub</code>风格）可以先看看<code>GitHub</code>的Help：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvZm9yay1hLXJlcG8v" title="https://help.github.com/articles/fork-a-repo/">Fork A Repo<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvdXNpbmctcHVsbC1yZXF1ZXN0cy8=" title="https://help.github.com/articles/using-pull-requests/">Using pull requests<i class="fa fa-external-link"></i></span> 。照着操作，给一个<code>GitHub</code>项目贡献你的提交，有操作经验再看指南容易意会。指南中给了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29sZHJhdGxlZS90cmFuc2xhdGlvbnMvYmxvYi9tYXN0ZXIvZ2l0LXdvcmtmbG93cy1hbmQtdHV0b3JpYWxzL3dvcmtmbG93LWZvcmtpbmcubWQjJUU1JUJDJTgwJUU1JThGJTkxJUU4JTgwJTg1Zm9yayVFNiVBRCVBMyVFNSVCQyU4RiVFNCVCQiU5MyVFNSVCQSU5Mw==" title="https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-forking.md#%E5%BC%80%E5%8F%91%E8%80%85fork%E6%AD%A3%E5%BC%8F%E4%BB%93%E5%BA%93">自己实现<code>Fork</code>的方法<i class="fa fa-external-link"></i></span>：<code>Fork</code>就是服务端的克隆。在指南的操练中使用代码托管服务（如<code>GitHub</code>、<code>Bitbucket</code>），可以点一下按钮就让开发者完成仓库的<code>fork</code>操作。</p>
<p><strong><em>PS</em></strong>：</p>
<p>文中<code>Pull Request</code>的介绍用的是<code>Bitbucket</code>代码托管服务，由于和<code>GITLAB</code>基本一样，如果你用的是<code>GITLAB</code>（我自己也主要使用<code>GITLAB</code>托管代码），不影响理解和操作。</p>
<h2 id="git-工作流指南"><a class="header-anchor" href="#git-工作流指南">¶</a><code>Git</code> 工作流指南</h2>
<p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览公司团队中最常用的几种<code>Git</code>工作流让大家可以上手使用。</p>
<p>在阅读的过程中请记住，本文中的几种工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。</p>
<p><img src="/uploads/images/posts/git/basic/git_workflow.png" alt="Git Workflows"></p>
<h2 id="集中式工作流"><a class="header-anchor" href="#集中式工作流">¶</a>集中式工作流</h2>
<p>如果你的开发团队成员已经很熟悉<code>Subversion</code>，集中式工作流让你无需去适应一个全新流程就可以体验<code>Git</code>带来的收益。这个工作流也可以作为向更<code>Git</code>风格工作流迁移的友好过渡。<br>
<img src="/uploads/images/posts/git/basic/git-workflow-svn.png" alt="Git Workflows: SVN-style"></p>
<p>转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上<code>Git</code>带来的收益。团队可以用和<code>Subversion</code>完全不变的方式来开发项目。</p>
<p>但使用<code>Git</code>加强开发的工作流，<code>Git</code>有相比<code>SVN</code>的几个优势。<br>
首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分修改独立开来 ——<br>
即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。</p>
<p>其次，<code>Git</code>提供了强壮的分支和合并模型。不像<code>SVN</code>，<code>Git</code>的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。</p>
<h3 id="工作方式"><a class="header-anchor" href="#工作方式">¶</a>工作方式</h3>
<p>像<code>Subversion</code>一样，集中式工作流以中央仓库作为项目所有修改的单点实体。相比<code>SVN</code>缺省的开发分支<code>trunk</code>，<code>Git</code>叫做<code>master</code>，所有修改提交到这个分支上。本工作流只用到<code>master</code>这一个分支。</p>
<p>开发者开始先克隆中央仓库。在自己的项目拷贝中像<code>SVN</code>一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。</p>
<p>要发布修改到正式项目中，开发者要把本地<code>master</code>分支的修改『推』到中央仓库中。这相当于<code>svn commit</code>操作，但<code>push</code>操作会把所有还不在中央仓库的本地提交都推上去。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-push-local.png" alt="git-workflow-svn-push-local"></p>
<h3 id="冲突解决"><a class="header-anchor" href="#冲突解决">¶</a>冲突解决</h3>
<p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。如果开发者本地的提交历史和中央仓库有分歧，<code>Git</code>会拒绝<code>push</code>提交否则会覆盖已经在中央库的正式提交。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-managingconflicts.png" alt="git-workflow-svn-managingconflicts"></p>
<p>在开发者提交自己功能修改到中央库前，需要先<code>fetch</code>在中央库的新增提交，<code>rebase</code>自己提交到中央库提交历史之上。<br>
这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的<code>SVN</code>的工作流中一样。</p>
<p>如果本地修改和上游提交有冲突，<code>Git</code>会暂停<code>rebase</code>过程，给你手动解决冲突的机会。<code>Git</code>解决合并冲突，用和生成提交一样的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhc3RhdHVz" title="https://www.atlassian.com/git/tutorial/git-basics#!status"><code>git status</code><i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhYWRk" title="https://www.atlassian.com/git/tutorial/git-basics#!add"><code>git add</code><i class="fa fa-external-link"></i></span>命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，<code>Git</code>可以很简单中止整个<code>rebase</code>操作，重来一次（或者让别人来帮助解决）。</p>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3>
<p>让我们一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。</p>
<h4 id="有人先初始化好中央仓库"><a class="header-anchor" href="#有人先初始化好中央仓库">¶</a>有人先初始化好中央仓库</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-initialize.png" alt=""></p>
<p>第一步，有人在服务器上创建好中央仓库。如果是新项目，你可以初始化一个空仓库；否则你要导入已有的<code>Git</code>或<code>SVN</code>仓库。</p>
<p>中央仓库应该是个裸仓库（<code>bare repository</code>），即没有工作目录（<code>working directory</code>）的仓库。可以用下面的命令创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host</span><br><span class="line">git init --bare /path/to/repo.git</span><br></pre></td></tr></table></figure>
<p>确保写上有效的<code>user</code>（<code>SSH</code>的用户名），<code>host</code>（服务器的域名或IP地址），<code>/path/to/repo.git</code>（你想存放仓库的位置）。<br>
注意，为了表示是一个裸仓库，按照约定加上<code>.git</code>扩展名到仓库名上。</p>
<h4 id="所有人克隆中央仓库"><a class="header-anchor" href="#所有人克隆中央仓库">¶</a>所有人克隆中央仓库</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-clone.png" alt=""></p>
<p>下一步，各个开发者创建整个项目的本地拷贝。通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhY2xvbmU=" title="https://www.atlassian.com/git/tutorial/git-basics#!clone"><code>git clone</code><i class="fa fa-external-link"></i></span>命令完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ssh://user@host/path/to/repo.git</span><br></pre></td></tr></table></figure>
<p>基于你后续会持续和克隆的仓库做交互的假设，克隆仓库时<code>Git</code>会自动添加远程别名<code>origin</code>指回『父』仓库。</p>
<h4 id="小明开发功能"><a class="header-anchor" href="#小明开发功能">¶</a>小明开发功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-1.png" alt=""></p>
<p>在小明的本地仓库中，他使用标准的<code>Git</code>过程开发功能：编辑、暂存（<code>Stage</code>）和提交。<br>
如果你不熟悉暂存区（<code>Staging Area</code>），这里说明一下：<strong>暂存区</strong>用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。<br>
这样你可以创建一个高度聚焦的提交，尽管你本地修改很多内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 查看本地仓库的修改状态</span></span><br><span class="line">git add <span class="comment"># 暂存文件</span></span><br><span class="line">git commit <span class="comment"># 提交文件</span></span><br></pre></td></tr></table></figure>
<p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作。<br>
对需要多个更简单更原子分块的大功能，这个做法是很有用的。</p>
<h4 id="小红开发功能"><a class="header-anchor" href="#小红开发功能">¶</a>小红开发功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-2.png" alt=""></p>
<p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。和小明一样，她也不关心中央仓库有没有新提交；<br>
当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。</p>
<h4 id="小明发布功能"><a class="header-anchor" href="#小明发布功能">¶</a>小明发布功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-3.png" alt=""></p>
<p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其它团队成员可以看到他的修改。他可以用下面的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVzaA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!push"><code>git push</code>命令<i class="fa fa-external-link"></i></span>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>注意，<code>origin</code>是在小明克隆仓库时<code>Git</code>创建的远程中央仓库别名。<code>master</code>参数告诉<code>Git</code>推送的分支。<br>
由于中央仓库自从小明克隆以来还没有被更新过，所以<code>push</code>操作不会有冲突，成功完成。</p>
<h4 id="小红试着发布功能"><a class="header-anchor" href="#小红试着发布功能">¶</a>小红试着发布功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-4.png" alt=""></p>
<p>一起来看看在小明发布修改后，小红<code>push</code>修改会怎么样？她使用完全一样的<code>push</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>但她的本地历史已经和中央仓库有分岐了，<code>Git</code>拒绝操作并给出下面很长的出错消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &apos;/path/to/repo.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)</span><br><span class="line">hint: before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>
<p>这避免了小红覆写正式的提交。她要先<code>pull</code>小明的更新到她的本地仓库合并上她的本地修改后，再重试。</p>
<h4 id="小红在小明的提交之上rebase"><a class="header-anchor" href="#小红在小明的提交之上rebase">¶</a>小红在小明的提交之上<code>rebase</code></h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-5.png" alt=""></p>
<p>小红用<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVsbA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!pull"><code>git pull</code><i class="fa fa-external-link"></i></span>合并上游的修改到自己的仓库中。<br>
这条命令类似<code>svn update</code>——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure>
<p><code>--rebase</code>选项告诉<code>Git</code>把小红的提交移到同步了中央仓库修改后的<code>master</code>分支的顶部，如下图所示：</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-6.png" alt=""></p>
<p>如果你忘加了这个选项，<code>pull</code>操作仍然可以完成，但每次<code>pull</code>操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。<br>
对于集中式工作流，最好是使用<code>rebase</code>而不是生成一个合并提交。</p>
<h4 id="小红解决合并冲突"><a class="header-anchor" href="#小红解决合并冲突">¶</a>小红解决合并冲突</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-7.png" alt=""></p>
<p><code>rebase</code>操作过程是把本地提交一次一个地迁移到更新了的中央仓库<code>master</code>分支之上。<br>
这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。<br>
这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入<code>Bug</code>的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p>
<p>如果小红和小明的功能是不相关的，不大可能在<code>rebase</code>过程中有冲突。如果有，<code>Git</code>在合并有冲突的提交处暂停<code>rebase</code>过程，输出下面的信息并带上相关的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict in &lt;some-file&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-8.png" alt=""></p>
<p><code>Git</code>很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhc3RhdHVz" title="https://www.atlassian.com/git/tutorial/git-basics#!status"><code>git status</code><i class="fa fa-external-link"></i></span>命令来查看哪里有问题。<br>
冲突文件列在<code>Unmerged paths</code>（未合并路径）一节中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Unmerged paths:</span><br><span class="line"># (use &quot;git reset HEAD &lt;some-file&gt;...&quot; to unstage)</span><br><span class="line"># (use &quot;git add/rm &lt;some-file&gt;...&quot; as appropriate to mark resolution)</span><br><span class="line">#</span><br><span class="line"># both modified: &lt;some-file&gt;</span><br></pre></td></tr></table></figure>
<p>接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmV3cml0aW5nLWdpdC1oaXN0b3J5IyFyZWJhc2U=" title="https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase"><code>git rebase</code><i class="fa fa-external-link"></i></span>完成剩下的事：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;some-file&gt; </span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>要做的就这些了。<code>Git</code>会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。</p>
<p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVsbA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!pull"><code>git pull --rebase</code><i class="fa fa-external-link"></i></span>命令前的样子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>
<h4 id="小红成功发布功能"><a class="header-anchor" href="#小红成功发布功能">¶</a>小红成功发布功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-svn-9.png" alt=""></p>
<p>小红完成和中央仓库的同步后，就能成功发布她的修改了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如你所见，仅使用几个<code>Git</code>命令我们就可以模拟出传统<code>Subversion</code>开发环境。对于要从<code>SVN</code>迁移过来的团队来说这太好了，但没有发挥出<code>Git</code>分布式本质的优势。</p>
<p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下 <code>功能分支工作流</code> 的收益。<br>
通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。</p>
<hr>
<h2 id="功能分支工作流"><a class="header-anchor" href="#功能分支工作流">¶</a>功能分支工作流</h2>
<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用<code>Pull Requests</code>的方式讨论变更。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature_branch.png" alt="Git Workflows: Feature Branch"></p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-1.png" alt=""></p>
<p>一旦你玩转了<a href="workflow-centralized.md">集中式工作流</a>，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。</p>
<p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在<code>master</code>分支上。<br>
这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。<br>
另外，也保证了<code>master</code>分支的代码一定不会是有问题的，极大有利于集成环境。</p>
<p>功能开发隔离也让<a href="pull-request.md"><code>pull requests</code>工作流</a>成功可能，<br>
<code>pull requests</code>工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。<br>
另外，如果你在功能开发中有问题卡住了，可以开一个<code>pull requests</code>来向同学们征求建议。<br>
这些做法的重点就是，<code>pull requests</code>让团队成员之间互相评论工作变成非常方便！</p>
<h3 id="工作方式-v2"><a class="header-anchor" href="#工作方式-v2">¶</a>工作方式</h3>
<p>功能分支工作流仍然用中央仓库，并且<code>master</code>分支还是代表了正式项目的历史。<br>
但不是直接提交本地历史到各自的本地<code>master</code>分支，开发者每次在开始新功能前先创建一个新分支。<br>
功能分支应该有个有描述性的名字，比如<code>animated-menu-items</code>或<code>issue-#1061</code>，这样可以让分支有个清楚且高聚焦的用途。</p>
<p>在<code>master</code>分支和功能分支之间，<code>Git</code>是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。</p>
<p>另外，功能分支也可以（且应该）<code>push</code>到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。<br>
由于<code>master</code>是仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题。当然，这样做也可以很方便地备份各自的本地提交。</p>
<h3 id="pull-requests"><a class="header-anchor" href="#pull-requests">¶</a><code>Pull Requests</code></h3>
<p>功能分支除了可以隔离功能的开发，也使得通过<a href="pull-request.md"><code>Pull Requests</code></a>讨论变更成为可能。<br>
一旦某个开发完成一个功能，不是立即合并到<code>master</code>，而是<code>push</code>到中央仓库的功能分支上并发起一个<code>Pull Request</code>请求去合并修改到<code>master</code>。<br>
在修改成为主干代码前，这让其它的开发者有机会先去<code>Review</code>变更。</p>
<p><code>Code Review</code>是<code>Pull Requests</code>的一个重要的收益，但<code>Pull Requests</code>目的是讨论代码一个通用方式。<br>
你可以把<code>Pull Requests</code>作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行<code>Code Review</code>。<br>
比如，一个开发者开发功能需要帮助时，要做的就是发起一个<code>Pull Request</code>，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。</p>
<p>一旦<code>Pull Request</code>被接受了，发布功能要做的就和集中式工作流就很像了。<br>
首先，确定本地的<code>master</code>分支和上游的<code>master</code>分支是同步的。然后合并功能分支到本地<code>master</code>分支并<code>push</code>已经更新的本地<code>master</code>分支到中央仓库。</p>
<p>仓库管理的产品解决方案像<span class="exturl" data-url="aHR0cDovL2JpdGJ1Y2tldC5vcmcv" title="http://bitbucket.org/"><code>Bitbucket</code><i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cDovL3d3dy5hdGxhc3NpYW4uY29tL3N0YXNo" title="http://www.atlassian.com/stash"><code>Stash</code><i class="fa fa-external-link"></i></span>，可以良好地支持<code>Pull Requests</code>。可以看看<code>Stash</code>的<span class="exturl" data-url="aHR0cHM6Ly9jb25mbHVlbmNlLmF0bGFzc2lhbi5jb20vZGlzcGxheS9TVEFTSC9Vc2luZytwdWxsK3JlcXVlc3RzK2luK1N0YXNo" title="https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash"><code>Pull Requests</code>文档<i class="fa fa-external-link"></i></span>。</p>
<h3 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h3>
<p>下面的示例演示了如何把<code>Pull Requests</code>作为<code>Code Review</code>的方式，但注意<code>Pull Requests</code>可以用于很多其它的目的。</p>
<h4 id="小红开始开发一个新功能"><a class="header-anchor" href="#小红开始开发一个新功能">¶</a>小红开始开发一个新功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-2.png" alt=""></p>
<p>在开始开发功能前，小红需要一个独立的分支。使用下面的命令<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFjaGVja291dA==" title="https://www.atlassian.com/git/tutorial/git-branches#!checkout">新建一个分支<i class="fa fa-external-link"></i></span>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b marys-feature master</span><br></pre></td></tr></table></figure>
<p>这个命令检出一个基于<code>master</code>名为<code>marys-feature</code>的分支，<code>Git</code>的<code>-b</code>选项表示如果分支还不存在则新建分支。<br>
这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
<h4 id="小红要去吃个午饭"><a class="header-anchor" href="#小红要去吃个午饭">¶</a>小红要去吃个午饭</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-3.png" alt=""></p>
<p>早上小红为新功能添加一些提交。<br>
去吃午饭前，<code>push</code>功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到小红的提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin marys-feature</span><br></pre></td></tr></table></figure>
<p>这条命令<code>push</code> <code>marys-feature</code>分支到中央仓库（<code>origin</code>），<code>-u</code>选项设置本地分支去跟踪远程对应的分支。<br>
设置好跟踪的分支后，小红就可以使用<code>git push</code>命令省去指定推送分支的参数。</p>
<h4 id="小红完成功能开发"><a class="header-anchor" href="#小红完成功能开发">¶</a>小红完成功能开发</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-4.png" alt=""></p>
<p>小红吃完午饭回来，完成整个功能的开发。<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFtZXJnZQ==" title="https://www.atlassian.com/git/tutorial/git-branches#!merge">在合并到<code>master</code>之前<i class="fa fa-external-link"></i></span>，<br>
她发起一个<code>Pull Request</code>让团队的其它人知道功能已经完成。但首先，她要确认中央仓库中已经有她最近的提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>然后，在她的<code>Git</code> <code>GUI</code>客户端中发起<code>Pull Request</code>，请求合并<code>marys-feature</code>到<code>master</code>，团队成员会自动收到通知。<br>
<code>Pull Request</code>很酷的是可以在相关的提交旁边显示评注，所以你可以对某个变更集提问。</p>
<h4 id="小黑收到-pull-request"><a class="header-anchor" href="#小黑收到-pull-request">¶</a>小黑收到 <code>Pull Request</code></h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-5.png" alt=""></p>
<p>小黑收到了<code>Pull Request</code>后会查看<code>marys-feature</code>的修改。决定在合并到正式项目前是否要做些修改，且通过<code>Pull Request</code>和小红来回地讨论。</p>
<h4 id="小红再做修改"><a class="header-anchor" href="#小红再做修改">¶</a>小红再做修改</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-6.png" alt=""></p>
<p>要再做修改，小红用和功能第一个迭代完全一样的过程。编辑、暂存、提交并<code>push</code>更新到中央仓库。小红这些活动都会显示在<code>Pull Request</code>上，小黑可以断续做评注。</p>
<p>如果小黑有需要，也可以把<code>marys-feature</code>分支拉到本地，自己来修改，他加的提交也会一样显示在<code>Pull Request</code>上。</p>
<h4 id="小红发布她的功能"><a class="header-anchor" href="#小红发布她的功能">¶</a>小红发布她的功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-feature-branch-7.png" alt=""></p>
<p>一旦小黑可以的接受<code>Pull Request</code>，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git pull origin marys-feature</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>无论谁来做合并，首先要检出<code>master</code>分支并确认是它是最新的。然后执行<code>git pull origin marys-feature</code>合并<code>marys-feature</code>分支到和已经和远程一致的本地<code>master</code>分支。<br>
你可以使用简单<code>git merge marys-feature</code>命令，但前面的命令可以保证总是最新的新功能分支。<br>
最后更新的<code>master</code>分支要重新<code>push</code>回到<code>origin</code>。</p>
<p>这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。<br>
但如果你偏爱线性的提交历史，可以在执行合并时<code>rebase</code>新功能到<code>master</code>分支的顶部，这样生成一个快进（<code>fast-forward</code>）的合并。</p>
<p>一些<code>GUI</code>客户端可以只要点一下『接受』按钮执行好上面的命令来自动化<code>Pull Request</code>接受过程。<br>
如果你的不能这样，至少在功能合并到<code>master</code>分支后能自动关闭<code>Pull Request</code>。</p>
<h4 id="与此同时-小明在做和小红一样的事"><a class="header-anchor" href="#与此同时-小明在做和小红一样的事">¶</a>与此同时，小明在做和小红一样的事</h4>
<p>当小红和小黑在<code>marys-feature</code>上工作并讨论她的<code>Pull Request</code>的时候，小明在自己的功能分支上做完全一样的事。</p>
<p>通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。</p>
<p>到了这里，但愿你发现了功能分支可以很直接地在 <code>集中式工作流</code> 的仅有的<code>master</code>分支上完成多功能的开发。<br>
另外，功能分支还使用了<code>Pull Request</code>，使得可以在你的版本控制<code>GUI</code>客户端中讨论某个提交。</p>
<p>功能分支工作流是开发项目异常灵活的方式。问题是，有时候太灵活了。对于大型团队，常常需要给不同分支分配一个更具体的角色。<br>
<code>Gitflow</code>工作流是管理功能开发、发布准备和维护的常用模式。</p>
<hr>
<h2 id="gitflow-工作流"><a class="header-anchor" href="#gitflow-工作流">¶</a><code>Gitflow</code> 工作流</h2>
<p><code>Gitflow</code>工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflows-gitflow.png" alt="Git Workflows: Gitflow Cycle"></p>
<p>这节介绍的<span class="exturl" data-url="aHR0cDovL252aWUuY29tL3Bvc3RzL2Etc3VjY2Vzc2Z1bC1naXQtYnJhbmNoaW5nLW1vZGVsLw==" title="http://nvie.com/posts/a-successful-git-branching-model/"><code>Gitflow</code>工作流<i class="fa fa-external-link"></i></span>借鉴自在<span class="exturl" data-url="aHR0cDovL252aWUuY29tLw==" title="http://nvie.com/">nvie<i class="fa fa-external-link"></i></span>的<em>Vincent Driessen</em>。</p>
<p><code>Gitflow</code>工作流定义了一个围绕项目发布的严格分支模型。虽然比<a href="workflow-feature-branch.md">功能分支工作流</a>复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p>
<p><code>Gitflow</code>工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。<br>
除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。<br>
当然你可以用上功能分支工作流所有的好处：<code>Pull Requests</code>、隔离实验性开发和更高效的协作。</p>
<h3 id="工作方式-v3"><a class="header-anchor" href="#工作方式-v3">¶</a>工作方式</h3>
<p><code>Gitflow</code>工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并<code>push</code>分支到要中央仓库中。</p>
<h3 id="历史分支"><a class="header-anchor" href="#历史分支">¶</a>历史分支</h3>
<p>相对使用仅有的一个<code>master</code>分支，<code>Gitflow</code>工作流使用2个分支来记录项目的历史。<code>master</code>分支存储了正式发布的历史，而<code>develop</code>分支作为功能的集成分支。<br>
这样也方便<code>master</code>分支上的所有提交分配一个版本号。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-1historical.png" alt=""></p>
<p>剩下要说明的问题围绕着这2个分支的区别展开。</p>
<h3 id="功能分支"><a class="header-anchor" href="#功能分支">¶</a>功能分支</h3>
<p>每个新功能位于一个自己的分支，这样可以<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVzaA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!push"><code>push</code>到中央仓库以备份和协作<i class="fa fa-external-link"></i></span>。<br>
但功能分支不是从<code>master</code>分支上拉出新分支，而是使用<code>develop</code>分支作为父分支。当新功能完成时，<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFtZXJnZQ==" title="https://www.atlassian.com/git/tutorial/git-branches#!merge">合并回<code>develop</code>分支<i class="fa fa-external-link"></i></span>。<br>
新功能提交应该从不直接与<code>master</code>分支交互。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-2feature.png" alt=""></p>
<p>注意，从各种含义和目的上来看，功能分支加上<code>develop</code>分支就是功能分支工作流的用法。但<code>Gitflow</code>工作流没有在这里止步。</p>
<h3 id="发布分支"><a class="header-anchor" href="#发布分支">¶</a>发布分支</h3>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-3release.png" alt=""></p>
<p>一旦<code>develop</code>分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从<code>develop</code>分支上<code>fork</code>一个发布分支。<br>
新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——<br>
这个分支只应该做<code>Bug</code>修复、文档生成和其它面向发布任务。<br>
一旦对外发布的工作都完成了，发布分支合并到<code>master</code>分支并分配一个版本号打好<code>Tag</code>。<br>
另外，这些从新建发布分支以来的做的修改要合并回<code>develop</code>分支。</p>
<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。<br>
这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。</p>
<p>常用的分支约定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于新建发布分支的分支: develop</span><br><span class="line">用于合并的分支: master</span><br><span class="line">分支命名: release-* 或 release/*</span><br></pre></td></tr></table></figure>
<h3 id="维护分支"><a class="header-anchor" href="#维护分支">¶</a>维护分支</h3>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-4maintenance.png" alt=""></p>
<p>维护分支或说是热修复（<code>hotfix</code>）分支用于生成快速给产品发布版本（<code>production releases</code>）打补丁，这是唯一可以直接从<code>master</code>分支<code>fork</code>出来的分支。<br>
修复完成，修改应该马上合并回<code>master</code>分支和<code>develop</code>分支（当前的发布分支），<code>master</code>分支应该用新的版本号打好<code>Tag</code>。</p>
<p>为<code>Bug</code>修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。<br>
你可以把维护分支想成是一个直接在<code>master</code>分支上处理的临时发布。</p>
<h3 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h3>
<p>下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。</p>
<h4 id="创建开发分支"><a class="header-anchor" href="#创建开发分支">¶</a>创建开发分支</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-5createdev.png" alt=""></p>
<p>第一步为<code>master</code>分支配套一个<code>develop</code>分支。简单来做可以<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFicmFuY2g=" title="https://www.atlassian.com/git/tutorial/git-branches#!branch">本地创建一个空的<code>develop</code>分支<i class="fa fa-external-link"></i></span>，<code>push</code>到服务器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>
<p>以后这个分支将会包含了项目的全部历史，而<code>master</code>分支将只包含了部分历史。其它开发者这时应该<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhY2xvbmU=" title="https://www.atlassian.com/git/tutorial/git-basics#!clone">克隆中央仓库<i class="fa fa-external-link"></i></span>，建好<code>develop</code>分支的跟踪分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ssh://user@host/path/to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>
<p>现在每个开发都有了这些历史分支的本地拷贝。</p>
<h4 id="小红和小明开始开发新功能"><a class="header-anchor" href="#小红和小明开始开发新功能">¶</a>小红和小明开始开发新功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-6maryjohnbeginnew.png" alt=""></p>
<p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于<code>master</code>分支，而是应该<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFjaGVja291dA==" title="https://www.atlassian.com/git/tutorial/git-branches#!checkout">基于<code>develop</code>分支<i class="fa fa-external-link"></i></span>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature develop</span><br></pre></td></tr></table></figure>
<p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
<h4 id="小红完成功能开发-v2"><a class="header-anchor" href="#小红完成功能开发-v2">¶</a>小红完成功能开发</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-7maryfinishes.png" alt=""></p>
<p>添加了提交后，小红觉得她的功能OK了。如果团队使用<code>Pull Requests</code>，这时候可以发起一个用于合并到<code>develop</code>分支。<br>
否则她可以直接合并到她本地的<code>develop</code>分支后<code>push</code>到中央仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge some-feature</span><br><span class="line">git push</span><br><span class="line">git branch -d some-feature</span><br></pre></td></tr></table></figure>
<p>第一条命令在合并功能前确保<code>develop</code>分支是最新的。注意，功能决不应该直接合并到<code>master</code>分支。<br>
冲突解决方法和<a href="workflow-centralized.md">集中式工作流</a>一样。</p>
<h4 id="小红开始准备发布"><a class="header-anchor" href="#小红开始准备发布">¶</a>小红开始准备发布</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-8maryprepsrelease.png" alt=""></p>
<p>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。<br>
像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1 develop</span><br></pre></td></tr></table></figure>
<p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p>
<p>只要小红创建这个分支并<code>push</code>到中央仓库，这个发布就是功能冻结的。任何不在<code>develop</code>分支中的新功能都推到下个发布循环中。</p>
<h4 id="小红完成发布"><a class="header-anchor" href="#小红完成发布">¶</a>小红完成发布</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-release-cycle-9maryfinishes.png" alt=""></p>
<p>一旦准备好了对外发布，小红合并修改到<code>master</code>分支和<code>develop</code>分支上，删除发布分支。合并回<code>develop</code>分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。<br>
另外，如果小红的团队要求<code>Code Review</code>，这是一个发起<code>Pull Request</code>的理想时机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure>
<p>发布分支是作为功能开发（<code>develop</code>分支）和对外发布（<code>master</code>分支）间的缓冲。只要有合并到<code>master</code>分支，就应该打好<code>Tag</code>以方便跟踪。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 0.1 -m <span class="string">"Initial public release"</span> master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<p><code>Git</code>有提供各种勾子（<code>hook</code>），即仓库有事件发生时触发执行的脚本。<br>
可以配置一个勾子，在你<code>push</code>中央仓库的<code>master</code>分支时，自动构建好对外发布。</p>
<h4 id="最终用户发现bug"><a class="header-anchor" href="#最终用户发现bug">¶</a>最终用户发现<code>Bug</code></h4>
<p><img src="/uploads/images/posts/git/basic/git-workflow-gitflow-enduserbug.png" alt=""></p>
<p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个<code>Ticket</code>抱怨当前版本的一个<code>Bug</code>。<br>
为了处理<code>Bug</code>，小红（或小明）从<code>master</code>分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回<code>master</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br><span class="line"><span class="comment"># Fix the bug</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>就像发布分支，维护分支中新加这些重要修改需要包含到<code>develop</code>分支中，所以小红要执行一个合并操作。然后就可以安全地<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFicmFuY2g=" title="https://www.atlassian.com/git/tutorial/git-branches#!branch">删除这个分支<i class="fa fa-external-link"></i></span>了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br><span class="line">git branch -d issue-<span class="comment">#001</span></span><br></pre></td></tr></table></figure>
<p>到了这里，但愿你对<a href="workflow-centralized.md">集中式工作流</a>、<a href="workflow-feature-branch.md">功能分支工作流</a>和<code>Gitflow</code>工作流已经感觉很舒适了。<br>
你应该也牢固的掌握了本地仓库的潜能，<code>push</code>/<code>pull</code>模式和<code>Git</code>健壮的分支和合并模型。</p>
<p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用<code>Git</code>不可违逆的条例。<br>
所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让<code>Git</code>为你所用。</p>
<hr>
<h2 id="forking-工作流"><a class="header-anchor" href="#forking-工作流">¶</a><code>Forking</code> 工作流</h2>
<p><code>Forking</code>工作流是分布式工作流，充分利用了<code>Git</code>在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（<code>developer</code>），并能接受不信任贡献者（<code>contributor</code>）的提交。</p>
<p><code>Forking</code>工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个<code>Git</code>仓库而不是1个：一个本地私有的，另一个服务端公开的。</p>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking.png" alt=""></p>
<p><code>Forking</code>工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能<code>push</code>代码到仅有的中央仓库中。<br>
开发者<code>push</code>到自己的服务端仓库，而只有项目维护者才能<code>push</code>到正式仓库。<br>
这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。</p>
<p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。<br>
也让这个工作流成为开源项目的理想工作流。</p>
<h3 id="工作方式-v4"><a class="header-anchor" href="#工作方式-v4">¶</a>工作方式</h3>
<p>和其它的<code>Git</code>工作流一样，<code>Forking</code>工作流要先有一个公开的正式仓库存储在服务器上。<br>
但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是<code>fork</code>正式项目在服务器上创建一个拷贝。</p>
<p>这个仓库拷贝作为他个人公开仓库 ——<br>
其它开发者不允许<code>push</code>到这个仓库，但可以<code>pull</code>到修改（后面我们很快就会看这点很重要）。<br>
在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhY2xvbmU=" title="https://www.atlassian.com/git/tutorial/git-basics#!clone"><code>git clone</code>命令<i class="fa fa-external-link"></i></span>克隆仓库到本地机器上，作为私有的开发环境。</p>
<p>要提交本地修改时，<code>push</code>提交到自己公开仓库中 —— 而不是正式仓库中。<br>
然后，给正式仓库发起一个<code>pull request</code>，让项目维护者知道有更新已经准备好可以集成了。<br>
对于贡献的代码，<code>pull request</code>也可以很方便地作为一个讨论的地方。</p>
<p>为了集成功能到正式代码库，维护者<code>pull</code>贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，<br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFtZXJnZQ==" title="https://www.atlassian.com/git/tutorial/git-branches#!merge">合并变更到自己本地的<code>master</code>分支<i class="fa fa-external-link"></i></span>，<br>
然后<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVzaA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!push"><code>push</code><i class="fa fa-external-link"></i></span><code>master</code>分支到服务器的正式仓库中。<br>
到此，贡献的提交成为了项目的一部分，其它的开发者应该执行<code>pull</code>操作与正式仓库同步自己本地仓库。</p>
<h3 id="正式仓库"><a class="header-anchor" href="#正式仓库">¶</a>正式仓库</h3>
<p>在<code>Forking</code>工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。<br>
从技术上来看，各个开发者仓库和正式仓库在<code>Git</code>看来没有任何区别。<br>
事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。</p>
<h3 id="forking-工作流的分支使用方式"><a class="header-anchor" href="#forking-工作流的分支使用方式">¶</a><code>Forking</code> 工作流的分支使用方式</h3>
<p>所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。<br>
各个开发者应该用分支隔离各个功能，就像在<a href="workflow-feature-branch.md">功能分支工作流</a>和<a href="workflow-forking.md"><code>Gitflow</code>工作流</a>一样。<br>
唯一的区别是这些分支被共享了。在<code>Forking</code>工作流中这些分支会被<code>pull</code>到另一个开发者的本地仓库中，而在功能分支工作流和<code>Gitflow</code>工作流中是直接被<code>push</code>到正式仓库中。</p>
<h3 id="示例-v4"><a class="header-anchor" href="#示例-v4">¶</a>示例</h3>
<h4 id="项目维护者初始化正式仓库"><a class="header-anchor" href="#项目维护者初始化正式仓库">¶</a>项目维护者初始化正式仓库</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-1.png" alt=""></p>
<p>和任何使用<code>Git</code>项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。<br>
通常这个仓库也会作为项目维护者的公开仓库。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhaW5pdA==" title="https://www.atlassian.com/git/tutorial/git-basics#!init">公开仓库应该是裸仓库<i class="fa fa-external-link"></i></span>，不管是不是正式代码库。<br>
所以项目维护者会运行像下面的命令来搭建正式仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host</span><br><span class="line">git init --bare /path/to/repo.git</span><br></pre></td></tr></table></figure>
<p><code>Bitbucket</code>和<code>Stash</code>提供了一个方便的<code>GUI</code>客户端以完成上面命令行做的事。<br>
这个搭建中央仓库的过程和前面提到的工作流完全一样。<br>
如果有现存的代码库，维护者也要<code>push</code>到这个仓库中。</p>
<h4 id="开发者fork正式仓库"><a class="header-anchor" href="#开发者fork正式仓库">¶</a>开发者<code>fork</code>正式仓库</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-2.png" alt=""></p>
<p>其它所有的开发需要<code>fork</code>正式仓库。<br>
可以用<code>git clone</code>命令<span class="exturl" data-url="aHR0cHM6Ly9jb25mbHVlbmNlLmF0bGFzc2lhbi5jb20vZGlzcGxheS9CSVRCVUNLRVQvU2V0K3VwK1NTSCtmb3IrR2l0" title="https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git">用<code>SSH</code>协议连通到服务器<i class="fa fa-external-link"></i></span>，<br>
拷贝仓库到服务器另一个位置 —— 是的，<code>fork</code>操作基本上就只是一个服务端的克隆。<br>
<code>Bitbucket</code>和<code>Stash</code>上可以点一下按钮就让开发者完成仓库的<code>fork</code>操作。</p>
<p>这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。</p>
<h4 id="开发者克隆自己fork出来的仓库"><a class="header-anchor" href="#开发者克隆自己fork出来的仓库">¶</a>开发者克隆自己<code>fork</code>出来的仓库</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-3.png" alt=""></p>
<p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的<code>git clone</code>命令。</p>
<p>在这个示例中，假定用<code>Bitbucket</code>托管了仓库。记住，如果这样的话各个开发者需要有各自的<code>Bitbucket</code>账号，<br>
使用下面命令克隆服务端自己的仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure>
<p>相比前面介绍的工作流只用了一个<code>origin</code>远程别名指向中央仓库，<code>Forking</code>工作流需要2个远程别名 ——<br>
一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用<code>origin</code>作为远程克隆的仓库的别名<br>
（这个别名会在运行<code>git clone</code>自动创建），<code>upstream</code>（上游）作为正式仓库的别名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://bitbucket.org/maintainer/repo</span><br></pre></td></tr></table></figure>
<p>需要自己用上面的命令创建<code>upstream</code>别名。这样可以简单地保持本地仓库和正式仓库的同步更新。<br>
注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://user@bitbucket.org/maintainer/repo.git</span><br></pre></td></tr></table></figure>
<p>这时在克隆和<code>pull</code>正式仓库时，需要提供用户的密码。</p>
<h4 id="开发者开发自己的功能"><a class="header-anchor" href="#开发者开发自己的功能">¶</a>开发者开发自己的功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-4.png" alt=""></p>
<p>在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJhc2ljcyMhY29tbWl0" title="https://www.atlassian.com/git/tutorial/git-basics#!commit">提交修改<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFicmFuY2g=" title="https://www.atlassian.com/git/tutorial/git-branches#!branch">新建分支<i class="fa fa-external-link"></i></span>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature</span><br><span class="line"><span class="comment"># Edit some code</span></span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure>
<p>所有的修改都是私有的直到<code>push</code>到自己公开仓库中。如果正式项目已经往前走了，可以用<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhcHVsbA==" title="https://www.atlassian.com/git/tutorial/remote-repositories#!pull"><code>git pull</code>命令<i class="fa fa-external-link"></i></span>获得新的提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure>
<p>由于开发者应该都在专门的功能分支上工作，<code>pull</code>操作结果会都是<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvZ2l0LWJyYW5jaGVzIyFtZXJnZQ==" title="https://www.atlassian.com/git/tutorial/git-branches#!merge">快进合并<i class="fa fa-external-link"></i></span>。</p>
<h4 id="开发者发布自己的功能"><a class="header-anchor" href="#开发者发布自己的功能">¶</a>开发者发布自己的功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-5.png" alt=""></p>
<p>一旦开发者准备好了分享新功能，需要做二件事。<br>
首先，通过<code>push</code>他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。<br>
他的<code>origin</code>远程别名应该已经有了，所以要做的就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-branch</span><br></pre></td></tr></table></figure>
<p>这里和之前的工作流的差异是，<code>origin</code>远程别名指向开发者自己的服务端仓库，而不是正式仓库。</p>
<p>第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。<br>
<code>Bitbucket</code>和<code>Stash</code>提供了<span class="exturl" data-url="aHR0cHM6Ly9jb25mbHVlbmNlLmF0bGFzc2lhbi5jb20vZGlzcGxheS9TVEFTSC9Vc2luZytwdWxsK3JlcXVlc3RzK2luK1N0YXNo" title="https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash"><code>Pull Request</code><i class="fa fa-external-link"></i></span>按钮，弹出表单让你指定哪个分支要合并到正式仓库。<br>
一般你会想集成你的功能分支到上游远程仓库的<code>master</code>分支中。</p>
<h4 id="项目维护者集成开发者的功能"><a class="header-anchor" href="#项目维护者集成开发者的功能">¶</a>项目维护者集成开发者的功能</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-6.png" alt=""></p>
<p>当项目维护者收到<code>pull request</code>，他要做的是决定是否集成它到正式代码库中。有二种方式来做：</p>
<ol>
<li>直接在<code>pull request</code>中查看代码</li>
<li><code>pull</code>代码到他自己的本地仓库，再手动合并</li>
</ol>
<p>第一种做法更简单，维护者可以在<code>GUI</code>中查看变更的差异，做评注和执行合并。<br>
但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmVtb3RlLXJlcG9zaXRvcmllcyMhZmV0Y2g=" title="https://www.atlassian.com/git/tutorial/remote-repositories#!fetch"><code>fetch</code><i class="fa fa-external-link"></i></span>功能分支，<br>
合并到他本地的<code>master</code>分支，解决冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https://bitbucket.org/user/repo feature-branch</span><br><span class="line"><span class="comment"># 查看变更</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>
<p>变更集成到本地的<code>master</code>分支后，维护者要<code>push</code>变更到服务器上的正式仓库，这样其它的开发者都能访问到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>注意，维护者的<code>origin</code>是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。</p>
<h4 id="开发者和正式仓库做同步"><a class="header-anchor" href="#开发者和正式仓库做同步">¶</a>开发者和正式仓库做同步</h4>
<p><img src="/uploads/images/posts/git/basic/git-workflows-forking-7.png" alt=""></p>
<p>由于正式代码库往前走了，其它的开发需要和正式仓库做同步：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure>
<p>如果你之前是使用<code>SVN</code>，<code>Forking</code>工作流可能看起来像是一个激进的范式切换（paradigm shift）。<br>
但不要害怕，这个工作流实际上就是在<a href="workflow-feature-branch.md">功能分支工作流</a>之上引入另一个抽象层。<br>
不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。</p>
<p>示例中解释了，一个贡献如何从一个开发者流到正式的<code>master</code>分支中，但同样的方法可以把贡献集成到任一个仓库中。<br>
比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。</p>
<p>这使得<code>Forking</code>工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。</p>
<hr>
<h2 id="pull-requests-v2"><a class="header-anchor" href="#pull-requests-v2">¶</a><code>Pull Requests</code></h2>
<p><code>Pull requests</code>是<code>Bitbucket</code>提供的让开发者更方便地进行协作的功能，提供了友好的<code>Web</code>界面可以在提议的修改合并到正式项目之前对修改进行讨论。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-bitbucket.png" alt=""></p>
<p>开发者向团队成员通知功能开发已经完成，<code>Pull Requests</code>是最简单的用法。<br>
开发者完成功能开发后，通过<code>Bitbucket</code>账号发起一个<code>Pull Request</code>。<br>
这样让涉及这个功能的所有人知道要去做<code>Code Review</code>和合并到<code>master</code>分支。</p>
<p>但是，<code>Pull Request</code>远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。<br>
如果变更有任何问题，团队成员反馈在<code>Pull Request</code>中，甚至<code>push</code>新的提交微调功能。<br>
所有的这些活动都直接跟踪在<code>Pull Request</code>中。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-overview.png" alt=""></p>
<p>相比其它的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。<br>
<code>SVN</code>和<code>Git</code>都能通过一个简单的脚本收到通知邮件；但是，讨论变更时，开发者通常只能去回复邮件。<br>
这样做会变得杂乱，尤其还要涉及后面的几个提交时。<br>
<code>Pull Requests</code>把所有相关功能整合到一个和<code>Bitbucket</code>仓库界面集成的用户友好<code>Web</code>界面中。</p>
<h3 id="解析-pull-request"><a class="header-anchor" href="#解析-pull-request">¶</a>解析 <code>Pull Request</code></h3>
<p>当要发起一个<code>Pull Request</code>，你所要做的就是请求（<code>Request</code>）另一个开发者（比如项目的维护者）<br>
来<code>pull</code>你仓库中一个分支到他的仓库中。这意味着你要提供4个信息以发起<code>Pull Request</code>：<br>
源仓库、源分支、目的仓库、目的分支。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-anatomy.png" alt=""></p>
<p>这几值多数<code>Bitbucket</code>都会设置上合适的缺省值。但取决你用的协作工作流，你的团队可能会要指定不同的值。<br>
上图显示了一个<code>Pull Request</code>请求合并一个功能分支到正式的<code>master</code>分支上，但可以有多种不同的<code>Pull Request</code>用法。</p>
<h3 id="工作方式-v5"><a class="header-anchor" href="#工作方式-v5">¶</a>工作方式</h3>
<p><code>Pull Request</code>可以和<a href="workflow-feature-branch.md">功能分支工作流</a>、<a href="workflow-gitflow.md"><code>Gitflow</code>工作流</a>或<a href="workflow-forking.md"><code>Forking</code>工作流</a>一起使用。<br>
但一个<code>Pull Request</code>要求要么分支不同要么仓库不同，所以不能用于<a href="workflow-centralized.md">集中式工作流</a>。<br>
在不同的工作流中使用<code>Pull Request</code>会有一些不同，但基本的过程是这样的：</p>
<ol>
<li>开发者在本地仓库中新建一个专门的分支开发功能。</li>
<li>开发者<code>push</code>分支修改到公开的<code>Bitbucket</code>仓库中。</li>
<li>开发者通过<code>Bitbucket</code>发起一个<code>Pull Request</code>。</li>
<li>团队的其它成员<code>review</code> <code>code</code>，讨论并修改。</li>
<li>项目维护者合并功能到官方仓库中并关闭<code>Pull Request</code>。</li>
</ol>
<p>本文后面内容说明，<code>Pull Request</code>在不同协作工作流中如何应用。</p>
<h3 id="在功能分支工作流中使用pull-request"><a class="header-anchor" href="#在功能分支工作流中使用pull-request">¶</a>在功能分支工作流中使用<code>Pull Request</code></h3>
<p>功能分支工作流用一个共享的<code>Bitbucket</code>仓库来管理协作，开发者在专门的分支上开发功能。<br>
但不是立即合并到<code>master</code>分支上，而是在合并到主代码库之前开发者应该开一个<code>Pull Request</code>发起功能的讨论。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-feature-branch.png" alt=""></p>
<p>功能分支工作流只有一个公开的仓库，所以<code>Pull Request</code>的目的仓库和源仓库总是同一个。<br>
通常开发者会指定他的功能分支作为源分支，<code>master</code>分支作为目的分支。</p>
<p>收到<code>Pull Request</code>后，项目维护者要决定如何做。如果功能没问题，就简单地合并到<code>master</code>分支，关闭<code>Pull Request</code>。<br>
但如果提交的变更有问题，他可以在<code>Pull Request</code>中反馈。之后新加的提交也会评论之后接着显示出来。</p>
<p>在功能还没有完全开发完的时候，也可能发起一个<code>Pull Request</code>。<br>
比如开发者在实现某个需求时碰到了麻烦，他可以发一个包含正在进行中工作的<code>Pull Request</code>。<br>
其它的开发者可以在<code>Pull Request</code>提供建议，或者甚至直接添加提交来解决问题。</p>
<h3 id="在gitflow工作流中使用pull-request"><a class="header-anchor" href="#在gitflow工作流中使用pull-request">¶</a>在<code>Gitflow</code>工作流中使用<code>Pull Request</code></h3>
<p><code>Gitflow</code>工作流和功能分支工作流类似，但围绕项目发布定义一个严格的分支模型。<br>
在<code>Gitflow</code>工作流中使用<code>Pull Request</code>让开发者在发布分支或是维护分支上工作时，<br>
可以有个方便的地方对关于发布分支或是维护分支的问题进行交流。</p>
<p><img src="/uploads/images/posts/git/basic/gitflow-workflow-pull-request.png" alt=""></p>
<p><code>Gitflow</code>工作流中<code>Pull Request</code>的使用过程和上一节中完全一致：<br>
当一个功能、发布或是热修复分支需要<code>Review</code>时，开发者简单发起一个<code>Pull Request</code>，<br>
团队的其它成员会通过<code>Bitbucket</code>收到通知。</p>
<p>新功能一般合并到<code>develop</code>分支，而发布和热修复则要同时合并到<code>develop</code>分支和<code>master</code>分支上。<br>
<code>Pull Request</code>可能用做所有合并的正式管理。</p>
<h3 id="在forking工作流中使用pull-request"><a class="header-anchor" href="#在forking工作流中使用pull-request">¶</a>在<code>Forking</code>工作流中使用<code>Pull Request</code></h3>
<p>在<code>Forking</code>工作流中，开发者<code>push</code>完成的功能到他自己的仓库中，而不是共享仓库。<br>
然后，他发起一个<code>Pull Request</code>，让项目维护者知道他的功能已经可以<code>Review</code>了。</p>
<p>在这个工作流，<code>Pull Request</code>的通知功能非常有用，<br>
因为项目维护者不可能知道其它开发者在他们自己的仓库添加了提交。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-forking-workflow-1.png" alt=""></p>
<p>由于各个开发有自己的公开仓库，<code>Pull Request</code>的源仓库和目标仓库不是同一个。<br>
源仓库是开发者的公开仓库，源分支是包含了修改的分支。<br>
如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是<code>master</code>分支。</p>
<p><code>Pull Request</code>也可以用于正式项目之外的其它开发者之间的协作。<br>
比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个<code>Pull Request</code>，<br>
用团队成员的<code>Bitbucket</code>仓库作为目标，而不是正式项目的仓库。<br>
然后使用相同的功能分支作为源和目标分支。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-forking-workflow-2.png" alt=""></p>
<p>2个开发者之间可以在<code>Pull Request</code>中讨论和开发功能。<br>
完成开发后，他们可以发起另一个<code>Pull Request</code>，请求合并功能到正式的<code>master</code>分支。<br>
在<code>Forking</code>工作流中，这样的灵活性让<code>Pull Request</code>成为一个强有力的协作工具。</p>
<h3 id="示例-v5"><a class="header-anchor" href="#示例-v5">¶</a>示例</h3>
<p>下面的示例演示了<code>Pull Request</code>如何在在<code>Forking</code>工作流中使用。<br>
也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。</p>
<p>在示例中，小红是个开发，小明是项目维护者。他们各自有一个公开的<code>Bitbucket</code>仓库，而小明的仓库包含了正式工程。</p>
<h4 id="小红fork正式项目"><a class="header-anchor" href="#小红fork正式项目">¶</a>小红<code>fork</code>正式项目</h4>
<p><img src="/uploads/images/posts/git/basic/pull-request-1.png" alt=""></p>
<p>小红先要<code>fork</code>小明的<code>Bitbucket</code>仓库，开始项目的开发。她登陆<code>Bitbucket</code>，浏览到小明的仓库页面，<br>
点<code>Fork</code>按钮。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-2.png" alt=""></p>
<p>然后为<code>fork</code>出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。</p>
<h4 id="小红克隆她的bitbucket仓库"><a class="header-anchor" href="#小红克隆她的bitbucket仓库">¶</a>小红克隆她的<code>Bitbucket</code>仓库</h4>
<p><img src="/uploads/images/posts/git/basic/pull-request-3.png" alt=""></p>
<p>下一步，小红克隆自己刚才<code>fork</code>出来的<code>Bitbucket</code>仓库，以在本机上准备出工作拷贝。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure>
<p>请记住，<code>git clone</code>会自动创建<code>origin</code>远程别名，是指向小红<code>fork</code>出来的仓库。</p>
<h4 id="小红开发新功能"><a class="header-anchor" href="#小红开发新功能">¶</a>小红开发新功能</h4>
<p><img src="/uploads/images/posts/git/basic/pull-request-4.png" alt=""></p>
<p>在开始改代码前，小红要为新功能先新建一个新分支。她会用这个分支作为<code>Pull Request</code>的源分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature</span><br><span class="line"><span class="comment"># 编辑代码</span></span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure>
<p>在新功能分支上，小红按需要添加提交。甚至如果小红觉得功能分支上的提交历史太乱了，她可以用<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWwvcmV3cml0aW5nLWdpdC1oaXN0b3J5IyFyZWJhc2UtaQ==" title="https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase-i">交互式<code>rebase</code><i class="fa fa-external-link"></i></span>来删除或压制提交。<br>
对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在<code>Pull Request</code>中做了什么内容。</p>
<h4 id="小红push功能到她的bitbucket仓库中"><a class="header-anchor" href="#小红push功能到她的bitbucket仓库中">¶</a>小红<code>push</code>功能到她的<code>Bitbucket</code>仓库中</h4>
<p><img src="/uploads/images/posts/git/basic/pull-request-5.png" alt=""></p>
<p>小红完成了功能后，<code>push</code>功能到她自己的<code>Bitbucket</code>仓库中（不是正式仓库），用下面简单的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin some-branch</span><br></pre></td></tr></table></figure>
<p>这时她的变更可以让项目维护者看到了（或者任何想要看的协作者）。</p>
<h4 id="小红发起pull-request"><a class="header-anchor" href="#小红发起pull-request">¶</a>小红发起<code>Pull Request</code></h4>
<p><img src="/uploads/images/posts/git/basic/example-6.png" alt=""></p>
<p><code>Bitbucket</code>上有了她的功能分支后，小红可以用她的<code>Bitbucket</code>账号浏览到她的<code>fork</code>出来的仓库页面，<br>
点右上角的【<code>Pull Request</code>】按钮，发起一个<code>Pull Request</code>。<br>
弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。</p>
<p>小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，<br>
而目标分支是<code>master</code>分支。另外，小红需要提供<code>Pull Request</code>的标题和描述信息。<br>
如果需要小明以外的人审核批准代码，她可以把这些人填在【Reviewers】文本框中。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-7.png" alt=""></p>
<p>创建好了<code>Pull Request</code>，通知会通过<code>Bitbucket</code>系统消息或邮件（可选）发给小明。</p>
<h4 id="小明review-pull-request"><a class="header-anchor" href="#小明review-pull-request">¶</a>小明review <code>Pull Request</code></h4>
<p><img src="/uploads/images/posts/git/basic/pull-request-8.png" alt=""></p>
<p>在小明的<code>Bitbucket</code>仓库页面的【<code>Pull Request</code>】Tab可以看到所有人发起的<code>Pull Request</code>。<br>
点击小红的<code>Pull Request</code>会显示出<code>Pull Request</code>的描述、功能的提交历史和每个变更的差异（<code>diff</code>）。</p>
<p>如果小明想要合并到项目中，只要点一下【<code>Merge</code>】按钮，就可以同意<code>Pull Request</code>并合并到<code>master</code>分支。</p>
<p>但如果像这个示例中一样小明发现了在小红的代码中的一个小<code>Bug</code>，要小红在合并前修复。<br>
小明可以在整个<code>Pull Request</code>上加上评注，或是选择历史中的某个提交加上评注。</p>
<p><img src="/uploads/images/posts/git/basic/pull-request-9.png" alt=""></p>
<h4 id="小红补加提交"><a class="header-anchor" href="#小红补加提交">¶</a>小红补加提交</h4>
<p>如果小红对反馈有任何疑问，可以在<code>Pull Request</code>中响应，把<code>Pull Request</code>当作是她功能讨论的论坛。</p>
<p>小红在她的功能分支新加提交以解决代码问题，并<code>push</code>到她的<code>Bitbucket</code>仓库中，就像前一轮中的做法一样。<br>
这些提交会进入的<code>Pull Request</code>，小明在原来的评注旁边可以再次<code>review</code>变更。</p>
<h4 id="小明接受pull-request"><a class="header-anchor" href="#小明接受pull-request">¶</a>小明接受<code>Pull Request</code></h4>
<p>最终，小明接受变更，合并功能分支到<code>Master</code>分支，并关闭<code>Pull Request</code>。<br>
至此，功能集成到项目中，其它的项目开发者可以用标准的<code>git pull</code>命令<code>pull</code>这些变更到自己的本地仓库中。</p>
<p>到了这里，你应该有了所有需要的工具来集成<code>Pull Request</code>到你自己的工作流。<br>
请记住，<code>Pull Request</code>并不是为了替代任何 <code>基于</code>Git<code>的协作工作流</code>，<br>
而是它们的一个便利的补充，让团队成员间的协作更轻松方便。</p>
<hr>
<h2 id="企业日常开发模式探索"><a class="header-anchor" href="#企业日常开发模式探索">¶</a>企业日常开发模式探索</h2>
<p>在看这部分前，请先回顾阅读业界认可的成功的 Git Branch Work Flow 模型 <span class="exturl" data-url="aHR0cDovL252aWUuY29tL3Bvc3RzL2Etc3VjY2Vzc2Z1bC1naXQtYnJhbmNoaW5nLW1vZGVsLw==" title="http://nvie.com/posts/a-successful-git-branching-model/">A Successful Git Branching Model<i class="fa fa-external-link"></i></span> ，了解日常开发中的场景，有助于熟悉下面的使用过程。</p>
<p>在企业开发中，使用 Git 作为版本控制软件最看重的还是结合公司自己搭建的 <span class="exturl" data-url="aHR0cHM6Ly9hYm91dC5naXRsYWIuY29tLw==" title="https://about.gitlab.com/">Gitlab<i class="fa fa-external-link"></i></span>，将 Code Review 加入打包部署持续集成的流程中，这样，代码开发完成，提交测试前，便可以对开发人员提交的代码进行 Review，发现潜在的问题，及时指导，对于新人来讲，也能更快更好的学习。</p>
<p>解决的需求场景如下：</p>
<ul>
<li>能支持日常迭代开发、紧急线上bug修复、多功能并行开发</li>
<li>大概50人左右的团队，平日迭代项目较多，且周期短（1~2周一个迭代）</li>
<li>能够通过tag重建整个系统</li>
<li>支持code review</li>
<li>所有上线的代码必须都是经过测试保证，且能自动同步到下一次的迭代中</li>
<li>能和公司的项目管理/持续集成系统整合</li>
</ul>
<p><img src="/uploads/images/posts/git/basic/branch_module.png" alt="图片"></p>
<p>上图就是 xirong 团队在日常开发中总结出来的适合企业开发的模式，下面进行简单的介绍，方便大家学习了解，欢迎提交 Issue 进行讨论。（本模式适合敏捷开发流程，小迭代上线，传统的瀑布开发模型并没有进行测试）</p>
<ol>
<li>
<p>迭代需求会、冲刺会后确定本次迭代的目标后，将迭代内容视为一个项目，在 Gitlab 上创建一个 Repository，初始化工程代码结构，根据上线日期，比如20150730上线，开出分支 release20150730、dev20150730 两个分支，dev 分支作为日常开发主干分支，release 分支作为提测打包、Code Review 的分支。</p>
</li>
<li>
<p>迭代开始，日常开发进行中，开发人员在 dev 分支上进行 Commit、Push 代码，并且解决掉日常协同开发中的冲突等问题，等到达到提测条件的时候，提测者，首先 Merge Master 分支上的最新代码 <code>git merge --no-ff origin/master</code> ，使得 Master 分支上的变更更新到迭代开发分支dev上面，之后，在 Gitlab 上面发起 <code>pull request</code> 请求，并指定 Code Review 人，请求的分支选择本次上线的 release 分支，即 release20150730。</p>
</li>
<li>
<p>被指定 Code Review 的人，对发起者的代码 Review 后，决定是否可以提交测试，若有问题，评论注释代码后，提交者对代码进行进行修改，重复步骤2，直到代码 Review 者认为 Ok。之后便可以借助自己公司的打包部署，对这些代码发布到测试环境验证。</p>
</li>
<li>
<p>步骤2-3重复多次后，就会达到一个稳定可发布的版本，即上线版本，上线后，将 release 版本上面最后的提交（图中0.2.4上线对应处）合并到 Master 分支上面，并打 Tag0.3。至此，一次完整的迭代开发完成。</p>
</li>
<li>
<p>若此次上线后，不久发现生产环境有 Bug 需要修复，则从 Tag 处新开分支 release_bugfix_20150731、dev_bugfix_20150731 ，开发人员从 dev_bugfix_20150731分支上进行开发，提测code review在 release_bugfix_20150731 分支上，具体步骤参考2-3，测试环境验证通过后，发布到线上，验证OK，合并到 Master 分支，并打 Tag0.2.3，此次 Bug 修复完毕，专为解 Bug 而生的这两个分支可以退伍了，删除release_bugfix_20150731、dev_bugfix_20150731两分支即可。（所有的历史 Commit 信息均已经提交到了 Master 分支上，不用担心丢失）</p>
</li>
</ol>
<p>这样经过上面的1-5步骤，企业日常迭代开发中的代码版本控制基本上就 Ok 了，有问题欢迎 Issue 讨论。</p>
<div class="alert alert-warning">
    本文转载于 [@xirong](https://github.com/xirong)
</div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇指南以大家在&lt;code&gt;SVN&lt;/code&gt;中已经广为熟悉使用的集中式工作流作为起点，循序渐进地演进到其它高效的分布式工作流，还介绍了如何配合使用便利的&lt;code&gt;Pull Request&lt;/code&gt;功能，体系地讲解了各种工作流的应用。&lt;br&gt;
如果你&lt;code&gt;Git&lt;/code&gt;用的还不多，可以从前面的讲的工作流开始操练。操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GIT&lt;/strong&gt; 是目前主流的&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFOCVCNSVCNyVFNiVBRCVBNS0lRTUlODUlQjMlRTQlQkElOEUlRTclODklODglRTYlOUMlQUMlRTYlOEUlQTclRTUlODglQjYjJUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU3JTg5JTg4JUU2JTlDJUFDJUU2JThFJUE3JUU1JTg4JUI2JUU3JUIzJUJCJUU3JUJCJTlG&quot; title=&quot;https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F&quot;&gt;分布式版本控制系统&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLw==&quot; title=&quot;https://git-scm.com/book/zh/v2/&quot;&gt;GIT 详细文档点击这里&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.charleslxh.top/categories/git/"/>
    
    
      <category term="Git" scheme="http://blog.charleslxh.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>邮件服务器 - sendmail/postfix</title>
    <link href="http://blog.charleslxh.top/2017/10/31/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8-sendmail-postfix/"/>
    <id>http://blog.charleslxh.top/2017/10/31/邮件服务器-sendmail-postfix/</id>
    <published>2017-10-31T02:59:29.000Z</published>
    <updated>2019-06-26T11:28:25.961Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Security" scheme="http://blog.charleslxh.top/tags/security/"/>
    
      <category term="Fail2ban" scheme="http://blog.charleslxh.top/tags/fail2ban/"/>
    
  </entry>
  
  <entry>
    <title>让你的服务器更安全 - 使用 Fail2ban 自动检测恶意攻击</title>
    <link href="http://blog.charleslxh.top/2017/10/31/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-fail2ban-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/"/>
    <id>http://blog.charleslxh.top/2017/10/31/让你的服务器更安全-使用-fail2ban-自动检测恶意攻击/</id>
    <published>2017-10-31T02:57:24.000Z</published>
    <updated>2017-10-31T03:48:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 <code>SSH</code> 服务的常见的攻击就是暴力破解攻击——远程攻击者通过不同的密码来无限次地进行登录尝试。当然 <code>SSH</code> 可以设置使用非密码验证验证方式来对抗这种攻击，例如 <code>公钥验证</code> 或者 <code>双重验证</code>。将不同的验证方法的优劣处先放在一边，如果我们必须使用密码验证方式怎么办？你是如何保护你的 <code>SSH</code> 服务器免遭暴力破解攻击的呢？</p>
<p><code>fail2ban</code> 是 <code>Linux</code> 上的一个著名的入侵保护的开源框架，它会监控多个系统的日志文件（例如：<code>/var/log/auth.log</code> 或者 <code>/var/log/secure</code>）并根据检测到的任何可疑的行为自动触发不同的防御动作。事实上，<code>fail2ban</code>在防御对 <code>SSH</code> 服务器的暴力密码破解上非常有用。</p>
<p>在这篇指导教程中，我会演示如何安装并配置 <code>fail2ban</code> 来保护 <code>SSH</code> 服务器以避免来自远程 <code>IP</code> 地址的暴力攻击。</p>
<a id="more"></a>
<p><strong>注：本文仅介绍在 Ubuntu 中的使用方式，其他系统请参考官方手册。</strong></p>
<h2 id="使用前提"><a class="header-anchor" href="#使用前提">¶</a>使用前提</h2>
<p>你的服务器需要安装 <code>Fail2ban</code>，安装如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fail2ban</span><br></pre></td></tr></table></figure>
<p>你也许会和其他服务配置使用，如：<code>iptables</code>、<code>sendmail</code>，详情请参考：</p>
<ul>
<li><a href="#">让你的服务器更安全 - 使用 Iptables 防火墙</a></li>
<li><a href="#">邮件服务器 - sendmail/postfix</a></li>
</ul>
<h2 id="如何使用"><a class="header-anchor" href="#如何使用">¶</a>如何使用</h2>
<h3 id="基础定义"><a class="header-anchor" href="#基础定义">¶</a>基础定义</h3>
<p>在使用之前，我们需要了解 <code>fail2ban</code> 中每个术语的意义与作用：</p>
<ul>
<li><code>filter</code>：过滤器，定义了一系列正在表达式，用于匹配指定日志文件中的每行内容。</li>
<li><code>action</code>：执行动作，当 <code>fail2ban</code> 检测到可疑行为时做出的动作。</li>
<li><code>jail</code>：任务，定义 <code>fail2ban</code> 的自动检测任务，可以自由组合 <code>filter</code> 和 <code>action</code>。</li>
<li><code>fail2ban-server</code>：<code>fail2ban</code> 服务器。</li>
<li><code>fail2ban-client</code>：<code>fail2ban</code> 客户端。</li>
</ul>
<h3 id="fail2ban-服务器"><a class="header-anchor" href="#fail2ban-服务器">¶</a>fail2ban 服务器</h3>
<p><code>fail2ban</code> 是一个多线程的服务器，用于执行 <code>fail2ban-client</code> 发送过来的命令。操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service fail2ban start|stop|restart</span><br></pre></td></tr></table></figure>
<h3 id="fail2ban-客户端"><a class="header-anchor" href="#fail2ban-客户端">¶</a>fail2ban 客户端</h3>
<p><code>fail2ban</code> 客户端，他通过 <code>Unix domain socket</code> 的方式连接服务器，通过发送命令去配置和操作 <code>fail2ban</code> 服务器，常用选项如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c &lt;DIR&gt;                configuration directory</span><br><span class="line">-s &lt;FILE&gt;               socket path</span><br><span class="line">-d                      dump configuration. For debugging</span><br><span class="line">-i                      interactive mode</span><br><span class="line">-v                      increase verbosity</span><br><span class="line">-q                      decrease verbosity</span><br><span class="line">-x                      force execution of the server</span><br><span class="line">-h, --<span class="built_in">help</span>              display this <span class="built_in">help</span> message</span><br><span class="line">-V, --version           <span class="built_in">print</span> the version</span><br></pre></td></tr></table></figure>
<p>配置文件里定义的所有配置都可以手动修改的，只需要通过 <code>set</code> 命令修改即可，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fail2ban-client <span class="built_in">set</span> loglevel 1</span><br><span class="line">$ sudo fail2ban-client <span class="built_in">set</span> logtarget STDERR</span><br></pre></td></tr></table></figure>
<p>启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fail2ban-client start</span><br></pre></td></tr></table></figure>
<p>更新配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo faile2ban-client reload</span><br></pre></td></tr></table></figure>
<h3 id="定义配置"><a class="header-anchor" href="#定义配置">¶</a>定义配置</h3>
<p>首先，我们先来看一下 <code>fail2ban</code> 的配置目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/etc/fail2ban/</span><br><span class="line">├── action.d</span><br><span class="line">│   ├── dummy.conf</span><br><span class="line">│   ├── hostsdeny.conf</span><br><span class="line">│   ├── iptables.conf</span><br><span class="line">│   ├── mail-whois.conf</span><br><span class="line">│   ├── mail.conf</span><br><span class="line">│   └── shorewall.conf</span><br><span class="line">├── fail2ban.conf</span><br><span class="line">├── fail2ban.local</span><br><span class="line">├── filter.d</span><br><span class="line">│   ├── apache-auth.conf</span><br><span class="line">│   ├── apache-noscript.conf</span><br><span class="line">│   ├── couriersmtp.conf</span><br><span class="line">│   ├── postfix.conf</span><br><span class="line">│   ├── proftpd.conf</span><br><span class="line">│   ├── qmail.conf</span><br><span class="line">│   ├── sasl.conf</span><br><span class="line">│   ├── sshd.conf</span><br><span class="line">│   └── vsftpd.conf</span><br><span class="line">├── jail.conf</span><br><span class="line">├── jail.local</span><br><span class="line">├── jail.d</span><br><span class="line">│   ├── your_jail.conf</span><br></pre></td></tr></table></figure>
<ul>
<li><code>action.d</code>：定义了一系列动作，如：发送邮件、使用 iptables 等，自定义的动作也放在该目录下。</li>
<li><code>fail2ban.conf</code>：定义了 <code>fail2ban</code> 服务配置。</li>
<li><code>filter.d</code>：定义了一系列过滤器，安装时会自带一些，自定义过滤器也房放在该目录下。</li>
<li><code>jail.conf</code>：定义自动检测任务，包含一些默认参数，定义了一些常用服务的检测规则。</li>
<li><code>jail.d</code>：自定义检测任务规则，存放在该目录下。</li>
</ul>
<h3 id="任务配置"><a class="header-anchor" href="#任务配置">¶</a>任务配置</h3>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFpbDJiYW4ub3JnL3dpa2kvaW5kZXgucGhwL01BTlVBTF8wXzgjSW50cm9kdWN0aW9u" title="https://www.fail2ban.org/wiki/index.php/MANUAL_0_8#Introduction">Fail2ban Official Manual<i class="fa fa-external-link"></i></span></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 &lt;code&gt;SSH&lt;/code&gt; 服务的常见的攻击就是暴力破解攻击——远程攻击者通过不同的密码来无限次地进行登录尝试。当然 &lt;code&gt;SSH&lt;/code&gt; 可以设置使用非密码验证验证方式来对抗这种攻击，例如 &lt;code&gt;公钥验证&lt;/code&gt; 或者 &lt;code&gt;双重验证&lt;/code&gt;。将不同的验证方法的优劣处先放在一边，如果我们必须使用密码验证方式怎么办？你是如何保护你的 &lt;code&gt;SSH&lt;/code&gt; 服务器免遭暴力破解攻击的呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fail2ban&lt;/code&gt; 是 &lt;code&gt;Linux&lt;/code&gt; 上的一个著名的入侵保护的开源框架，它会监控多个系统的日志文件（例如：&lt;code&gt;/var/log/auth.log&lt;/code&gt; 或者 &lt;code&gt;/var/log/secure&lt;/code&gt;）并根据检测到的任何可疑的行为自动触发不同的防御动作。事实上，&lt;code&gt;fail2ban&lt;/code&gt;在防御对 &lt;code&gt;SSH&lt;/code&gt; 服务器的暴力密码破解上非常有用。&lt;/p&gt;
&lt;p&gt;在这篇指导教程中，我会演示如何安装并配置 &lt;code&gt;fail2ban&lt;/code&gt; 来保护 &lt;code&gt;SSH&lt;/code&gt; 服务器以避免来自远程 &lt;code&gt;IP&lt;/code&gt; 地址的暴力攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Security" scheme="http://blog.charleslxh.top/tags/security/"/>
    
      <category term="Fail2ban" scheme="http://blog.charleslxh.top/tags/fail2ban/"/>
    
  </entry>
  
  <entry>
    <title>让你的服务器更安全 - 使用 Iptables 防火墙</title>
    <link href="http://blog.charleslxh.top/2017/10/31/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-Iptables-%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://blog.charleslxh.top/2017/10/31/让你的服务器更安全-使用-Iptables-防火墙/</id>
    <published>2017-10-31T02:53:34.000Z</published>
    <updated>2017-10-31T02:58:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Firewall" scheme="http://blog.charleslxh.top/tags/firewall/"/>
    
      <category term="Security" scheme="http://blog.charleslxh.top/tags/security/"/>
    
      <category term="Iptables" scheme="http://blog.charleslxh.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Linux 成长之路（一）</title>
    <link href="http://blog.charleslxh.top/2017/08/03/linux-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.charleslxh.top/2017/08/03/linux-成长之路（一）/</id>
    <published>2017-08-03T14:05:13.000Z</published>
    <updated>2017-08-03T14:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux</code> 是非常流行的服务器操作系统，他的命令行非常优美，使用起来非常高效、快捷。让我们一起来享受这 <code>窈窕淑女</code>。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 是非常流行的服务器操作系统，他的命令行非常优美，使用起来非常高效、快捷。让我们一起来享受这 &lt;code&gt;窈窕淑女&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Command" scheme="http://blog.charleslxh.top/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 - 回溯</title>
    <link href="http://blog.charleslxh.top/2017/06/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9B%9E%E6%BA%AF/"/>
    <id>http://blog.charleslxh.top/2017/06/03/正则表达式-回溯/</id>
    <published>2017-06-03T02:34:53.000Z</published>
    <updated>2017-06-03T05:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>在正则表达式实现中，回溯是匹配过程的基本组成部分，它是正则表达式如此好用和强大的根源。然而，回溯计算代价很高，如果设计失误，将导致失控。回溯是影响整体性能的唯一因素，理解它的工作原理，以及如何减小使用频率，可能是编写高效正则表达式的关键点。</p>
<a id="more"></a>
<h2 id="匹配原理"><a class="header-anchor" href="#匹配原理">¶</a>匹配原理</h2>
<p>当一个正则表达式扫描目标字符串时，从左到右逐个扫描正则表达式的组成部分，在每个位置上测试能不能找到一个匹配。对于每一个量词和分支，都必须确定如何继续进行。如果是一个量词（如 <code>*</code>、<code>+</code>、<code>?</code>或者 <code>{2,}</code>），那么正则表达式必须确定何时尝试匹配更多的字符；如果遇到分支（通过|操作符），那么正则表达式必须从这些选项中选择一个进行尝试。</p>
<p>当正则表达式做出这样的决定时，如果有必要，它会记住另一个选项，以备返回后使用。如果所选方案匹配成功，正则表达式将继续扫描正则表达式模板，如果其余部分匹配也成功了，那么匹配就结束了。但是，如果所选择的方案未能发现相应匹配，或者后来的匹配也失败了，正则表达式将回溯到最后一个决策点，然后在剩余的选项中选择一个。继续这样，直到找到一个匹配，或者量词和分支选项的所有可能的排列组合都尝试失败后放弃这一过程，然后移动到此过程开始位置的下一个字符上，重复此过程。</p>
<p>例如，下面的代码演示了这一过程是如何通过回溯处理分支的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/h(ello|appy) hippo/.test(<span class="string">"hello there, happy hippo"</span>);</span><br></pre></td></tr></table></figure>
<p>上面一行正则表达式用于匹配 <code>hello hippo</code> 或 <code>happy hippo</code>。测试一开始要查找一个 <code>h</code>，目标字符串的第一个字母恰好就是 <code>h</code>，立刻就找到了。接下来，子表达式<code>（ello|appy）</code>提供了两个处理选项。正则表达式选择最左边的选项（<strong>分支选择总是从左到右进行</strong>），检查 <code>ello</code> 是否匹配字符串的下一个字符，确实匹配，然后正则表达式又匹配了后面的空格。</p>
<p>然而，在接下来的匹配中正则表达式“走进了死胡同”，因为 <code>hippo</code> 中的 <code>h</code> 不能匹配字符串中的下一个字母 <code>t</code>。此时正则表达式还不能放弃，因为它还没有尝试过所有的选择，随后它回溯到最后一个检查点（在匹配了首字母h 之后的那个位置上）并尝试匹配第二个分支选项。但由于匹配没有成功，而且也没有更多的选项了，正则表达式认为从字符串的第一个字符开始匹配是不能成功的，因此它从第二个字符开始重新进行查找。正则表达式没有找到h，继续向后找，直到第 <code>14</code> 个字母才找到，它匹配 <code>happy</code> 的那个 <code>h</code>。随后正则表达式再次进入分支过程，这次 <code>ello</code> 未能匹配，但在回溯之后的第二次分支中，它匹配了整个字符串 <code>happy hippo</code>，匹配成功了。</p>
<p>再如，下面代码演示了带重复量词的回溯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;p&gt;Para 1.&lt;/p&gt;"</span> +<span class="string">"&lt;img src='smiley.jpg'&gt;"</span> +<span class="string">"&lt;p&gt;Para 2.&lt;/p&gt;"</span> +<span class="string">"&lt;div&gt;Div.&lt;/div&gt;"</span>;  </span><br><span class="line">/&lt;p&gt;.*&lt;\/p&gt;<span class="regexp">/i.test(str);</span></span><br></pre></td></tr></table></figure>
<p>正则表达式先匹配了字符串开始的 3 个字母 <code>&lt;p&gt;</code>，然后是 <code>.*</code>。点号表示匹配除换行符以外的任意字符，星号这个 <strong>贪性量词</strong>(表示重复零次或多次)，匹配尽量多的次数。因为目标字符串中没有换行符，正则表达式将匹配剩下的全部字符串！不过由于正则表达式模板中还有更多内容需要匹配，所以正则表达式尝试匹配 <code>&lt;</code> 。由于在字符串末尾匹配不成功，因此每次回溯一个字符，继续尝试匹配&lt;，直到正则表达式回到 <code>&lt;/div&gt;</code> 标签的 <code>&lt;</code> 位置。接下来尝试匹配 <code>\/</code>（转义反斜杠），匹配成功，然后匹配 <code>p</code>，匹配不成功。正则表达式继续回溯，重复此过程，直到第二段末尾时终于匹配了 <code>&lt;/p&gt;</code>。匹配返回成功需要从第一段头部一直扫描到最后一个的末尾，这可能不是我们想要的结果。</p>
<p>将正则表达式中的 <code>贪性量词</code> 改为 <code>惰性量词</code>（详细请查看<a href="/2017/06/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%B4%AA%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/#%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-laziness">如何设置量词为惰性</a>），以匹配单个段落。<code>惰性量词</code>的回溯工作以相反方式进行。当正则表达式 <code>/&lt;p&gt;.*?&lt;\/p&gt;/</code> 推进到 <code>.*?</code> 时，首先尝试全部跳过，然后继续匹配 <code>&lt;\/p&gt;</code>。</p>
<p>这样做是因为 <code>*?</code> 匹配零次或多次，尽可能少重复，尽可能少意味着可以重复零次。但是，当随后的 <code>&lt;</code> 在字符串的这一点上匹配失败时，正则表达式回溯并尝试下一个最小的字符数：1 个。正则表达式继续像这样向前回溯到第一段的末尾，在那里量词后面的 <code>&lt;\/p&gt;</code> 得到完全匹配。</p>
<p>如果目标字符串只有一个段落，那么此正则表达式的 <code>贪性匹配</code> 和 <code>惰性匹配</code> 是等价的，但尝试匹配的过程不同。</p>
<p>当一个正则表达式占用浏览器几秒甚至更长时间时，问题原因很可能是回溯失控。为说明此问题，给出下面的正则表达式，它的目标是匹配整个 <code>HTML</code> 文件。此表达式被拆分成多行是为了适合页面显示。与其他正则表达式不同，<code>JavaScript</code> 在没有选项时可使点号匹配任意字符，包括换行符，所以此例中以 <code>[\s\S]</code> 匹配任意字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;html&gt;[\s\S]*?&lt;head&gt;[\s\S]*?&lt;title&gt;[\s\S]*?&lt;\/title&gt;[\s\S]*?&lt;\/head&gt; </span><br><span class="line">[\s\S]*?&lt;body&gt;[\s\S]*?&lt;\/body&gt;[\s\S]*?&lt;\/html&gt;<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>回溯会大大降低我们正则表达式的执行效率与时间，所以我们需要尽量减少回溯的次数，这需要我们更加仔细的考虑每一个正则表达式。</p>
<h2 id="参考连接"><a class="header-anchor" href="#参考连接">¶</a>参考连接</h2>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vYmFja3JlZi5odG1s" title="http://www.regular-expressions.info/backref.html">Backreferences<i class="fa fa-external-link"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9sb3Zla3kuZ2l0aHViLmlvLzIwMTcvMDUvMzEvcmVndWxhci1leHByZXNzaW9ucy1jYXRhc3Ryb3BoaWMtYmFja3RyYWNraW5n" title="https://loveky.github.io/2017/05/31/regular-expressions-catastrophic-backtracking">正则表达式中的悲观回溯<i class="fa fa-external-link"></i></span><br>
<span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vY2F0YXN0cm9waGljLmh0bWw=" title="http://www.regular-expressions.info/catastrophic.html">Runaway Regular Expressions: Catastrophic Backtracking<i class="fa fa-external-link"></i></span><br>
<span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vcG9zc2Vzc2l2ZS5odG1s" title="http://www.regular-expressions.info/possessive.html">Regex Tutorial - Possessive Quantifiers<i class="fa fa-external-link"></i></span><br>
<span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vYXRvbWljLmh0bWw=" title="http://www.regular-expressions.info/atomic.html">Regex Tutorial - Atomic Grouping<i class="fa fa-external-link"></i></span></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正则表达式实现中，回溯是匹配过程的基本组成部分，它是正则表达式如此好用和强大的根源。然而，回溯计算代价很高，如果设计失误，将导致失控。回溯是影响整体性能的唯一因素，理解它的工作原理，以及如何减小使用频率，可能是编写高效正则表达式的关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://blog.charleslxh.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://blog.charleslxh.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 - 贪性与惰性</title>
    <link href="http://blog.charleslxh.top/2017/06/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%B4%AA%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/"/>
    <id>http://blog.charleslxh.top/2017/06/03/正则表达式-贪性与惰性/</id>
    <published>2017-06-03T01:57:39.000Z</published>
    <updated>2017-06-03T05:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用正则表达式中的 <code>贪性</code>、<code>惰性</code>、<code>支配性</code> 的量词可以控制表达式匹配过程，我们知道量词 <code>？</code>、<code>*</code>、<code>+</code> 的意义，可以指定相关模式出现的次数，默认的情况下我们使用的量词均是是贪婪量词，它的匹配过程是从整个字符串开始查看，如果不匹配就去掉最后一个，再看看是否匹配，如此循环一直到匹配或字符串空为止。不管是 <code>贪性</code> 还是 <code>惰性</code> ，在正则表达式在匹配失败时都会触发 <code>正则表达式回溯</code>（详情查看<a href="/2017/06/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9B%9E%E6%BA%AF/">正则表达式 - 回溯</a>），从而影响其性能。</p>
<a id="more"></a>
<h2 id="量词-quantifier"><a class="header-anchor" href="#量词-quantifier">¶</a>量词（Quantifier）</h2>
<p>首先，我们需要了解一下正则表达式的量词，正则表达式中有如下几种量词 <code>?</code>、<code>+</code>、<code>*</code>、<code>{n}</code>、<code>{n,m}</code>、<code>{n,}</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">量词</th>
<th style="text-align:center">匹配规则</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配出现 0 次或 1 次</td>
<td style="text-align:center">/a?/.test(‘abcd’);</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配出现 1 次或多次</td>
<td style="text-align:center">/a+/.test(‘aaaaaaaa’);</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配出现 0 次或 1 次或多次</td>
<td style="text-align:center">/a*/.test(‘bbbbb’);</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">匹配刚好出现 n 次</td>
<td style="text-align:center">/a{5}/.test(‘aaaab’);</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">匹配最少出现 n 次最多出现 m 次</td>
<td style="text-align:center">a{1,3}/.test(‘aaabbb’);</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">匹配最少出现 n 次</td>
<td style="text-align:center">/a{3,}/.test(‘aabbb’);</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<h2 id="贪性匹配-greediness"><a class="header-anchor" href="#贪性匹配-greediness">¶</a>贪性匹配（greediness）</h2>
<p>从字面意思我们就可以知道，所谓的&quot;贪婪&quot;的意思就是，如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪性匹配。默认情况下，<code>?</code>、<code>+</code>、<code>*</code>、<code>{n}</code>、<code>{n,m}</code>、<code>{n,}</code>都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。</p>
<blockquote>
<p>贪性匹配就是匹配尽可能 <code>多</code> 的内容。</p>
</blockquote>
<p>假如我们有一个字符串 <code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code>，我们使用 <code>/&lt;.+&gt;/g</code> 来匹配，我们期望匹配到两段文本，第一段为 <code>&lt;EM&gt;</code>，第二段匹配文本为 <code>&lt;/EM&gt;</code>，但是只得到了一段匹配文本：<code>&lt;EM&gt;first&lt;/EM&gt;</code>，很显然结果不尽人意，并不是我们想要的。</p>
<p>出现这种情况的罪魁祸首就是 <code>+</code> 是 <code>贪性匹配（greedy）</code> 的，正则表达式引擎执行 <code>+</code> 量词时尽可能的重复匹配前面的符号 <code>.</code>  <code>回溯</code>（即：正则表达式放弃上一次匹配，吐出一个匹配的字符给剩下的字符串），再一次使用下一个正则表达式符号来匹配剩下的字符串，如此反复 <code>回溯</code> 直到匹配成功或回溯到 0。通过下面的例子，可以更加直观的解释他的过程。</p>
<p><code>&lt;.+&gt;</code> 匹配字符串 <code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code> 的过程：</p>
<ol>
<li>第一个符号为 <code>&lt;</code>，所以它将会匹配到字符串中的第一个 <code>&lt;</code> 字符。</li>
<li>第二个符号为 <code>.</code>，匹配任意字符（除了换行），使用 <code>+</code> 重复匹配，所以它将会不断重复匹配，直到他匹配到句尾，则匹配失败，<code>.+</code> 匹配了 <code>EM&gt;first&lt;/EM&gt; test</code>。</li>
<li>到目前为止 <code>&lt;.+</code> 匹配的字符串为：<code>&lt;EM&gt;first&lt;/EM&gt; test</code>。</li>
<li>正则表达式引擎开始对下一个正则表达式符号 <code>&gt;</code> 进行匹配，但字符串还未匹配的只剩下换行符了，于是匹配失败。</li>
<li>由于第三个符号 <code>&gt;</code> 匹配失败，正则表达式引擎回溯，回溯会使 <code>.+</code> <code>减少（吐出）</code>一个字符，回溯后的匹配状况是 <code>.+</code> 匹配 <code>EM&gt;first&lt;/EM&gt; tes</code>。</li>
<li>正则表达式引擎使用符号 <code>&gt;</code> 匹配 <code>t</code>，结果依然不匹配。</li>
<li>如果重复 <code>5</code>、<code>6</code> 两步，直到 <code>.+</code> 匹配 <code>EM&gt;first&lt;/EM</code> 时，正则表达式使用符号 <code>&gt;</code> 匹配 <code>&gt; test</code>，匹配成功。</li>
<li>正则表达式引擎报告 <code>&lt;EM&gt;first&lt;/EM&gt;</code> 就是匹配上的文本。</li>
</ol>
<h2 id="可选性-optional"><a class="header-anchor" href="#可选性-optional">¶</a>可选性（optional）</h2>
<p>我们都知道量词 <code>?</code> 可以使前一个正则表达式字符是可选的，如：<code>colou?r</code> 可以匹配 <code>colour</code> 和 <code>color</code>。当然你也可以使用括号 <code>()</code> 将一些字符或规则标识为可选的，如：Nov(ember)? 将会匹配 <code>Nov</code> 和 <code>November</code>，当然你也可以使用 <code>{0,1}</code> 拉替代 <code>?</code>，他们是等价的。</p>
<p>默认情况下 <code>?</code> 也是 <code>贪性匹配</code> 的，即：他会优先尝试匹配该字符存在的情况，如果匹配失败，则尝试匹配该字符不存在的情况。例如：<br>
我们用 <code>Feb 23(rd)?</code> 表达式匹配 <code>Today is Feb 23rd, 2003</code> 文本，匹配结果是 <code>Feb 23rd</code> 而不是 <code>Feb 23</code>。</p>
<p>如果是：<code>Feb 23(rd)??</code> 呢？结果却是 <code>Feb 23</code>，是不是很奇妙，下面我们将会详细解答惰性匹配的原理。</p>
<h2 id="惰性匹配-laziness"><a class="header-anchor" href="#惰性匹配-laziness">¶</a>惰性匹配（laziness）</h2>
<p>惰性模式就是一旦匹配到合适的就结束，不在继续匹配下去了，在重复量词后面添加问号 <code>?</code> 即可形成惰性匹配。惰性匹配会尽可能少的匹配字符，但是必须要满足整个匹配模式。</p>
<blockquote>
<p>惰性匹配就是匹配尽可能 <code>少</code> 的内容。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">量词</th>
<th style="text-align:center">匹配规则</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">??</td>
<td style="text-align:center">匹配出现 0 次或 1 次，优先匹配 0 次</td>
</tr>
<tr>
<td style="text-align:center">+?</td>
<td style="text-align:center">匹配出现 1 次或多次，尽可能重复少的次数，不过最少次数是 1</td>
</tr>
<tr>
<td style="text-align:center">*?</td>
<td style="text-align:center">匹配出现 0 次或 1 次或多次，尽可能重复少的次数</td>
</tr>
<tr>
<td style="text-align:center">{n}?</td>
<td style="text-align:center">匹配刚好出现 n 次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}?</td>
<td style="text-align:center">匹配最少出现 n 次最多出现 m 次，尽可能重复少的次数，不过最少次数是 n</td>
</tr>
<tr>
<td style="text-align:center">{n,}?</td>
<td style="text-align:center">匹配最少出现 n 次，尽可能重复少的次数，不过最少次数是 n</td>
</tr>
</tbody>
</table>
<p><code>&lt;.+?&gt;</code> 匹配字符串 <code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code> 的过程：</p>
<ol>
<li>第一个符号为 <code>&lt;</code>，所以它将会匹配到字符串中的第一个 <code>&lt;</code> 字符。</li>
<li>第二个符号为 <code>.</code>，匹配任意字符（除了换行），使用 <code>+?</code> 重复匹配，因为是惰性匹配，所以 <code>+</code> 会尽可能少的匹配（最少一次），第一次 <code>.+</code> 匹配了 <code>E</code>。</li>
<li>正则表达式引擎开始对下一个正则表达式符号 <code>&gt;</code> 进行匹配，剩下的字符串 <code>M&gt;first&lt;/EM&gt; test</code> 的第一个字符为 <code>M</code>，于是匹配失败。</li>
<li>由于第三个符号 <code>&gt;</code> 匹配失败，正则表达式引擎回溯，回溯会使 <code>.+</code> <code>扩大（吞入）</code>一个字符，而不是贪性匹配的<code>减少</code>一个字符，回溯后的匹配状况是 <code>.+</code> 匹配 <code>EM</code>。</li>
<li>正则表达式引擎开始对下一个正则表达式符号 <code>&gt;</code> 进行匹配，剩下的字符串 <code>&gt;first&lt;/EM&gt; test</code> 的第一个字符为 <code>&gt;</code>，于是匹配成功。</li>
<li>正则表达式引擎报告 <code>&lt;EM&gt;</code> 就是匹配上的文本。</li>
</ol>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>贪性匹配，正则引擎会一直匹配到字符串最后；当匹配为 <code>false</code> 时，就回溯以找到倒数第一个匹配位置，返回匹配结果。</p>
<p>惰性匹配，正则引擎会匹配到符合 <code>pattern</code> 的末尾位置那个字符，然后再往后走一步，发现匹配为 <code>false</code> 时，就回溯以找到最近一个匹配为 <code>true</code> 的位置，返回匹配结果。</p>
<p>改善 <code>贪性</code>、<code>惰性</code>，减少回溯次数，能够有利于正则表达式的执行效率，写出更好的正则表达式。</p>
<p>如我们可以使用 <code>&lt;[^&gt;]+&gt;</code> 来取代 <code>&lt;.+?&gt;</code> 和 <code>&lt;.+&gt;</code>，这样回溯次数就降到了 <code>0</code> 次，当然，效率和耗时都是最佳的。</p>
<h2 id="参考连接"><a class="header-anchor" href="#参考连接">¶</a>参考连接</h2>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vb3B0aW9uYWwuaHRtbA==" title="http://www.regular-expressions.info/optional.html">Optional Items<i class="fa fa-external-link"></i></span><br>
<span class="exturl" data-url="aHR0cDovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vcmVwZWF0Lmh0bWw=" title="http://www.regular-expressions.info/repeat.html">Repetition with Star and Plus<i class="fa fa-external-link"></i></span></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用正则表达式中的 &lt;code&gt;贪性&lt;/code&gt;、&lt;code&gt;惰性&lt;/code&gt;、&lt;code&gt;支配性&lt;/code&gt; 的量词可以控制表达式匹配过程，我们知道量词 &lt;code&gt;？&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt; 的意义，可以指定相关模式出现的次数，默认的情况下我们使用的量词均是是贪婪量词，它的匹配过程是从整个字符串开始查看，如果不匹配就去掉最后一个，再看看是否匹配，如此循环一直到匹配或字符串空为止。不管是 &lt;code&gt;贪性&lt;/code&gt; 还是 &lt;code&gt;惰性&lt;/code&gt; ，在正则表达式在匹配失败时都会触发 &lt;code&gt;正则表达式回溯&lt;/code&gt;（详情查看&lt;a href=&quot;/2017/06/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9B%9E%E6%BA%AF/&quot;&gt;正则表达式 - 回溯&lt;/a&gt;），从而影响其性能。&lt;/p&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://blog.charleslxh.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://blog.charleslxh.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程安全与非线程安全</title>
    <link href="http://blog.charleslxh.top/2017/05/27/java-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.charleslxh.top/2017/05/27/java-线程安全与非线程安全/</id>
    <published>2017-05-27T09:17:05.000Z</published>
    <updated>2017-06-03T03:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>还记得初学 Java 的时候，老师是这样告诉我们的：ArrayList 是非线程安全的，Vector 是线程安全的；HashMap 是非线程安全的，HashTable 是线程安全的；StringBuilder 是非线程安全的，StringBuffer 是线程安全的。对，很快我们也记住了这一面试宝典，但是当面试官继续往下问你：什么是线程安全和非线程安全？他们有什么区别？什么场景用哪一种模式？这时，你是不是会吐上一口老血。</p>
<a id="more"></a>
<h2 id="原子性"><a class="header-anchor" href="#原子性">¶</a>原子性</h2>
<p>首先，我们吸纳来了解一下什么是原子性，这个概念大家或许耳熟能详。</p>
<p>在多线程访问共享资源（同一块内存），能保证在同一时间，只有一个进程访问该资源，并且该操作不可被分割，不能被打断，必须执行到结束，不会被线程切换打断，这就是原子性。</p>
<p>这个在 Java 多线程编程中是老生常谈的话题了，所谓的原子操作是指不会被线程调度机制打断的操作，这种操作从执行开始就会一直执行结束，中间不会出现任何的 context switch（线程的切换）。</p>
<h2 id="线程安全与非线程安全"><a class="header-anchor" href="#线程安全与非线程安全">¶</a>线程安全与非线程安全</h2>
<p>那到底什么是线程安全呢，其实线程安全就是一个原子操作，大致是：当一个线程调用一个线程安全的方法时，其他的线程就不能调用该线程安全的方法了，而必须要等到正在执行的线程结束后才能调用。</p>
<p>其实也是线程同步的问题，若是每个线程对共享内存都做只读操作，而无写操作，那么这块共享内存是线程安全，若是有多个线程会同时进行写操作，这时候就需要考虑线程同步的问题了，这就涉及到了线程安全之间问题。</p>
<h2 id="线程安全模拟"><a class="header-anchor" href="#线程安全模拟">¶</a>线程安全模拟</h2>
<p>首先，我们用 <code>ArrayList</code> 来演示非线程安全，我们在主线程有一个 <code>ArrayList</code>，在主线程开启四个子线程分别往这个列表中插入值，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还记得初学 Java 的时候，老师是这样告诉我们的：ArrayList 是非线程安全的，Vector 是线程安全的；HashMap 是非线程安全的，HashTable 是线程安全的；StringBuilder 是非线程安全的，StringBuffer 是线程安全的。对，很快我们也记住了这一面试宝典，但是当面试官继续往下问你：什么是线程安全和非线程安全？他们有什么区别？什么场景用哪一种模式？这时，你是不是会吐上一口老血。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.charleslxh.top/categories/java/"/>
    
    
      <category term="Java" scheme="http://blog.charleslxh.top/tags/java/"/>
    
      <category term="线程" scheme="http://blog.charleslxh.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 使用 Docker 搭建 ELK 系统</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E4%BD%BF%E7%94%A8-docker-%E6%90%AD%E5%BB%BA-elk-%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-使用-docker-搭建-elk-系统/</id>
    <published>2017-05-27T06:03:24.000Z</published>
    <updated>2017-05-27T10:21:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
      <category term="Docker" scheme="http://blog.charleslxh.top/categories/elasticsearch/docker/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="ELK" scheme="http://blog.charleslxh.top/tags/elk/"/>
    
      <category term="LogStash" scheme="http://blog.charleslxh.top/tags/logstash/"/>
    
      <category term="Kibana" scheme="http://blog.charleslxh.top/tags/kibana/"/>
    
      <category term="Docker" scheme="http://blog.charleslxh.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 使用 IK 中文分词插件</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E4%BD%BF%E7%94%A8-ik-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-使用-ik-中文分词插件/</id>
    <published>2017-05-27T06:03:13.000Z</published>
    <updated>2017-05-27T10:20:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
      <category term="NLP" scheme="http://blog.charleslxh.top/categories/elasticsearch/nlp/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="IK" scheme="http://blog.charleslxh.top/tags/ik/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 构建自己的 HanLP 中文分词插件</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-hanlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-构建自己的-hanlp-中文分词插件/</id>
    <published>2017-05-27T06:02:57.000Z</published>
    <updated>2017-05-27T10:19:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="HanLP" scheme="http://blog.charleslxh.top/tags/hanlp/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 搜索建议的实现</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-搜索建议的实现/</id>
    <published>2017-05-27T06:02:43.000Z</published>
    <updated>2017-05-27T10:19:59.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="搜索建议" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 同义词方案</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E5%90%8C%E4%B9%89%E8%AF%8D%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-同义词方案/</id>
    <published>2017-05-27T06:02:21.000Z</published>
    <updated>2017-05-27T10:20:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="同义词" scheme="http://blog.charleslxh.top/tags/%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎 ElasticSearch - 如何搭配使用 IK 和 HanLP</title>
    <link href="http://blog.charleslxh.top/2017/05/27/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-elasticsearch-%E5%A6%82%E4%BD%95%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8-ik-%E5%92%8C-hanlp/"/>
    <id>http://blog.charleslxh.top/2017/05/27/搜索引擎-elasticsearch-如何搭配使用-ik-和-hanlp/</id>
    <published>2017-05-27T06:01:38.000Z</published>
    <updated>2019-06-26T11:28:18.762Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/categories/elasticsearch/"/>
    
      <category term="NLP" scheme="http://blog.charleslxh.top/categories/elasticsearch/nlp/"/>
    
    
      <category term="搜索引擎" scheme="http://blog.charleslxh.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="ElasticSearch" scheme="http://blog.charleslxh.top/tags/elasticsearch/"/>
    
      <category term="IK" scheme="http://blog.charleslxh.top/tags/ik/"/>
    
      <category term="HanLP" scheme="http://blog.charleslxh.top/tags/hanlp/"/>
    
  </entry>
  
  <entry>
    <title>让你的服务器更安全 - 初始化服务器配置</title>
    <link href="http://blog.charleslxh.top/2017/05/20/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.charleslxh.top/2017/05/20/让你的服务器更安全-初始化服务器配置/</id>
    <published>2017-05-20T02:20:33.000Z</published>
    <updated>2017-06-03T03:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你创建或购买了了一个新的的服务器的时候，有一些必要的步骤作来配置你的服务器，比如：<code>root</code> 用户权限过大问题、<code>SSH</code> 安全连接问题等等、使用虚拟内存等等。这将增加您的服务器的安全性和可用性，并将为后续行动提供坚实的基础。</p>
<a id="more"></a>
<p>下面我将会解释如何在 <code>Ubuntu 14.04</code> 中使用做一些安全性基本配置。</p>
<h2 id="创建用户"><a class="header-anchor" href="#创建用户">¶</a>创建用户</h2>
<h3 id="使用-root-用户登录"><a class="header-anchor" href="#使用-root-用户登录">¶</a>使用 Root 用户登录</h3>
<h3 id="创建一个新用户"><a class="header-anchor" href="#创建一个新用户">¶</a>创建一个新用户</h3>
<h3 id="赋予-root-权限"><a class="header-anchor" href="#赋予-root-权限">¶</a>赋予 Root 权限</h3>
<h3 id="禁用-root-用户"><a class="header-anchor" href="#禁用-root-用户">¶</a>禁用 Root 用户</h3>
<h2 id="添加公钥认证"><a class="header-anchor" href="#添加公钥认证">¶</a>添加公钥认证</h2>
<h2 id="配置时区和-ntp"><a class="header-anchor" href="#配置时区和-ntp">¶</a>配置时区和 NTP</h2>
<h2 id="创建虚拟内存"><a class="header-anchor" href="#创建虚拟内存">¶</a>创建虚拟内存</h2>
<h2 id="配置时区和-ntp-v2"><a class="header-anchor" href="#配置时区和-ntp-v2">¶</a>配置时区和 NTP</h2>
<h2 id="配置防火墙"><a class="header-anchor" href="#配置防火墙">¶</a>配置防火墙</h2>
<p>配置防火墙是提高服务器安全方面很重要的一部分，他可以有限提高你的服务器的安全性和可用性，具体配置可以参考 <a href="/2017/05/20/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-UFW-%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99/#more">让你的服务器更安全 - 使用 UFW 开启防火墙</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你创建或购买了了一个新的的服务器的时候，有一些必要的步骤作来配置你的服务器，比如：&lt;code&gt;root&lt;/code&gt; 用户权限过大问题、&lt;code&gt;SSH&lt;/code&gt; 安全连接问题等等、使用虚拟内存等等。这将增加您的服务器的安全性和可用性，并将为后续行动提供坚实的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Security" scheme="http://blog.charleslxh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>让你的服务器更安全 - 使用 UFW 开启防火墙</title>
    <link href="http://blog.charleslxh.top/2017/05/20/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-UFW-%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://blog.charleslxh.top/2017/05/20/让你的服务器更安全-使用-UFW-开启防火墙/</id>
    <published>2017-05-20T01:58:52.000Z</published>
    <updated>2017-10-31T02:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UFW</code>(Uncomplicated Firewall) 是一个非常容易上手的 <code>iptables</code> 类防火墙配置工具，这个工具可以对出入服务的网络数据进行分割、过滤、转发等等细微的控制，进而实现诸如防火墙、 <code>NAT</code> 等功能。它简化了 <code>iptable</code> 那复杂的配置过程。我们都知道 <code>iptable</code> 非常强大、灵活，但是对于初学者来学习如何使用它正确的配置防火墙是比较难的，但是你又想保护你的网络，<code>UFW</code> 将会是你最好的选择。</p>
<a id="more"></a>
<p>下面我将会解释如何在 <code>Ubuntu 14.04</code> 中使用 <code>UFW</code> 安装、配置防火墙。</p>
<h2 id="使用前提"><a class="header-anchor" href="#使用前提">¶</a>使用前提</h2>
<p>在你使用这片教材之前，我希望你有一个独立的 <code>no-root</code> 超级管理员用户 - 拥有 <code>root</code> 的所有权限。你可以查看我这篇文章 <a href="/2017/05/20/%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E5%AE%89%E5%85%A8-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">让你的服务器更安全 - 初始化服务器配置</a> 中创建用户相关步骤。</p>
<p>一般来说 <code>UFW</code> 是默认会被安装的，假如你的系统中没有安装，你可以使用 <code>apt-get</code> 来安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ufw</span><br></pre></td></tr></table></figure>
<h2 id="使用-ipv6"><a class="header-anchor" href="#使用-ipv6">¶</a>使用 IPv6</h2>
<p>如果你的 <code>Ubuntu</code> 服务器已启用 <code>IPv6</code>，为了确保 <code>UFW</code> 能支持 <code>IPv6</code> 协议。</p>
<p>打开 <code>UFW</code> 的相关配置，使用你最喜欢的编辑器，这里我使用 <code>vim</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/default/ufw</span><br></pre></td></tr></table></figure>
<p>然后，确认 <code>IPv6</code> 是否设置成 <code>yes</code>，如果没有则设置为 <code>yes</code>，大致如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">IPV6=yes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>退出并保存，当 <code>UFW</code> 开启时，它将会同时支持 <code>IPv4</code> 和 <code>IPv6</code> 的配置规则。</p>
<h2 id="查看-ufw-状态和配置规则"><a class="header-anchor" href="#查看-ufw-状态和配置规则">¶</a>查看 UFW 状态和配置规则</h2>
<p>在任何时间，你都可以检查它的状态和配置规则，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw status verbose</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>UFW</code> 并没有开启，它将会输出如下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output:</span></span><br><span class="line">Status: inactive</span><br></pre></td></tr></table></figure>
<p>假如你已经开启了防火墙，它将会输出状态为 <code>active</code>，并列出你所配置的规则。例如：你允许来自任何地方的 <code>SSH</code> 连接，将将会输出如下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output</span></span><br><span class="line">Status: active</span><br><span class="line">Logging: on (low)</span><br><span class="line">Default: deny (incoming), allow (outgoing), disabled (routed)</span><br><span class="line">New profiles: skip</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22/tcp                     ALLOW IN    Anywhere</span><br></pre></td></tr></table></figure>
<p>像这样通过 <code>status</code> 就可以检查你的防火墙状态和配置了。</p>
<blockquote>
<p><strong>注意：在开启防火墙之前，你需要确保你允许了 SSH 连接，否则当你关闭远程连接后，你就无法再连上了。博主自己就曾用这招坑了自己！<img class="emoji" draggable="false" alt="😂" src="https://twemoji.maxcdn.com/2/72x72/1f602.png"></strong></p>
</blockquote>
<h2 id="设置默认规则"><a class="header-anchor" href="#设置默认规则">¶</a>设置默认规则</h2>
<p>当你需要开始配置你的防火墙规则时，首先，你需要设置默认规则：拒绝所有流入连接，允许流出连接。意思是，不允许任何人连接你的主机，允许主机内的任何应用访问外部网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw default deny incoming</span><br><span class="line">$ sudo ufw default allow outgoing</span><br></pre></td></tr></table></figure>
<h2 id="开启-ssh-连接"><a class="header-anchor" href="#开启-ssh-连接">¶</a>开启 SSH 连接</h2>
<p>上面我们已经设置了默认不接受任何外来连接，同样也包括了 <code>SSH</code> 使用的 <code>22</code> 端口。所以，为了我们能通过 <code>SSH</code> 来操作主机，所以我们需要配置允许 <code>SSH</code> 连接到我们的主机上。</p>
<p>通过如下命令来配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ufw allow ssh</span></span><br></pre></td></tr></table></figure>
<p>这个配置将会允许所有 <code>22</code> 端口上的连接，默认 <code>22</code> 端口是被 <code>SSH</code> 监听的。<code>UFW</code> 知道什么是 <code>ssh</code>，因为它在 <code>/etc/services</code> 中已经被定义好了。</p>
<p>当然我们也可以指定允许 <code>22</code> 端口的所有连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow 22</span><br></pre></td></tr></table></figure>
<p>这个和上面一个命令的作用是一样的。</p>
<h2 id="开启-ufw"><a class="header-anchor" href="#开启-ufw">¶</a>开启 UFW</h2>
<p>上面已经允许 <code>SSH</code> 连接，我们就可以放心的开启防火墙了，使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure>
<p>在这个过程中，你将会收到一条警告信息（<code>command may disrupt existing ssh connections.</code>），需要你手动确认，输入 <code>y</code> 按回车即可。</p>
<p><img class="emoji" draggable="false" alt="😄" src="https://twemoji.maxcdn.com/2/72x72/1f604.png"> 太棒了，我们已经开启了防火墙，你可以再一次通过 <code>sudo ufw status verbose</code> 来查看。</p>
<h2 id="配置其他规则"><a class="header-anchor" href="#配置其他规则">¶</a>配置其他规则</h2>
<h3 id="http-https"><a class="header-anchor" href="#http-https">¶</a>HTTP/HTTPS</h3>
<p>当我们部署 <code>WEB</code> 引用服务器时，我们需要使用 <code>80</code> 或 <code>443</code> 端口来接受请求，这是我们需要开启这两个端口，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow http</span><br><span class="line">$ sudo ufw allow https</span><br></pre></td></tr></table></figure>
<p>或者，你可以指定端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow 80</span><br><span class="line">$ sudo ufw allow 443</span><br></pre></td></tr></table></figure>
<h3 id="ftp"><a class="header-anchor" href="#ftp">¶</a>FTP</h3>
<p><code>FTP</code> 连接一般用于非加密文件传输，它默认监听 <code>21</code> 端口，也许你永远都不会用到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow ftp</span><br></pre></td></tr></table></figure>
<p>或者，你可以指定端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow 21/tcp</span><br></pre></td></tr></table></figure>
<h2 id="指定端口范围"><a class="header-anchor" href="#指定端口范围">¶</a>指定端口范围</h2>
<p>你可以指定一个端口范围，来配置防火墙策略，当有些服务需要使用多个端口时，这个就起到了作用。</p>
<p>如，为了允许所有 <code>X11</code> 连接，他们使用的端口范围是 <code>6000</code> ~ <code>6007</code>，你可以这样配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow 6000:6007/tcp</span><br><span class="line">$ sudo ufw allow 6000:6007/udp</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>指定端口范围时，你必须指定协议类型（<code>TCP</code> 或 <code>UDP</code>）。</strong></p>
</blockquote>
<h2 id="指定-ip-地址"><a class="header-anchor" href="#指定-ip-地址">¶</a>指定 IP 地址</h2>
<p>使用 <code>UFW</code> 工作的时候，你可以指定 <code>IP</code> 地址，例如：假如你想允许来自某一个 <code>IP</code> 所有连接，你可以指定 <code>from</code> 这个 <code>IP</code> 地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from 192.168.66.213</span><br></pre></td></tr></table></figure>
<p>上面的配置将会允许 <code>192.168.66.213</code> 连接到我们主机的任何开放了的端口。</p>
<p>我们还可以指定只允许某个 <code>IP</code> 到主机某一个端口的连接，拒绝某个 <code>IP</code> 到主机其他所有端口的连接，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from 192.168.66.213 to any port 80</span><br></pre></td></tr></table></figure>
<p>上面配置中，我们只允许 <code>192.168.66.213</code> 连接到我们的 <code>80</code> 端口。</p>
<h2 id="配置子网"><a class="header-anchor" href="#配置子网">¶</a>配置子网</h2>
<p>当你需要允许子网内所有的 <code>IP</code>，你可以 <code>CIDR</code> 的格式来配置，例如：当你需要允许 <code>IP</code> 地址从 <code>192.168.1.1</code> 到 <code>192.168.1.254</code> 内所有 <code>IP</code> 的连接时，你可以这样配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from 192.168.1.1/24</span><br></pre></td></tr></table></figure>
<p>当然，像上面一样，我们也可以同时指定端口号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from 192.168.1.1/24 to any port 22</span><br></pre></td></tr></table></figure>
<p>上面配置中，我们允许 <code>192.168.1.1/24</code> 内的所有主机通过 <code>SSH</code> 连接我们的主机。</p>
<h2 id="指定网络接口"><a class="header-anchor" href="#指定网络接口">¶</a>指定网络接口</h2>
<p>如果您想创建只适用于特定网络接口的防火墙规则，您可以通过指定 <code>allow in on</code> 加上<strong>网络接口的名称</strong> 来配置规则。</p>
<p>在配置之前你可以先查找所有的网络接口，再配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output Excerpt:</span></span><br><span class="line">...</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state</span><br><span class="line">...</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面列举了网络接口的一些信息，他们通常叫做 <code>eth0</code> 或 <code>eth1</code> 之类的名字。</p>
<p>假如你的 <code>eth0</code> 为公网地址，你同事需要向外开放 <code>80</code> 端口，你可以如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow <span class="keyword">in</span> on eth0 to any port 80</span><br></pre></td></tr></table></figure>
<p>上面配置中，你的服务器将会接受来自于公网的 HTTP 请求。</p>
<p>另外，假如你想你的 <code>MySQL</code> 服务器（监听 <code>3306</code>）只接受通过内网网卡 <code>eth1</code> 的请求，你可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow <span class="keyword">in</span> on eth1 to any port 3306</span><br></pre></td></tr></table></figure>
<p>如上配置中，只有在用一个内网中的服务器才能连接你的 <code>MySQL</code> 服务器。</p>
<h2 id="添加拒绝连接规则"><a class="header-anchor" href="#添加拒绝连接规则">¶</a>添加拒绝连接规则</h2>
<p>假如你没有修改过我们上面设置过的默认规则，它将会拒绝所有的外来连接，通常情况下，这样大大的简化了你配置一系列的防火墙规则，比如要求你创建指定端口啊，指定 <code>IP</code> 啊等等。但是，如果你想拒绝某个 <code>IP</code> 源或者某个网段的特定连接；也许你知道攻击源就来自于某个 <code>IP</code> 或某个网段；再者，你想把默认外接规则(incomming rule) 设置为 <strong>allow</strong>，这是你就需要指定某些拒绝规则了。</p>
<p>配置 <em>拒绝规则</em> ，更我们上面配置 <em>允许规则</em> 是一样的方式，只不过将 <code>allow</code> 改为 <code>deny</code>。</p>
<p>如：拒绝所有 HTTP 连接，即：拒绝所有连接 <code>80</code> 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw deny http</span><br></pre></td></tr></table></figure>
<p>当然，也可以指定端口号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw deny 80</span><br></pre></td></tr></table></figure>
<p>拒绝某一个 <code>192.168.1.10</code> 通过 <code>SSH</code> 连接到我们的主机上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw deny from 192.168.1.10 to any port 22</span><br></pre></td></tr></table></figure>
<p>如果你想书写更多的 <em>拒绝规则</em> ，请参考之前描述的 <em>允许规则</em> 书写方式，将 <code>allow</code> 改为 <code>deny</code> 即可。</p>
<p>现在我们知道如何添加 <em>允许规则</em> 和 <em>拒绝规则</em>，但是我们还不知道如何删除规则，没关系，我们再往下看。</p>
<h2 id="删除规则"><a class="header-anchor" href="#删除规则">¶</a>删除规则</h2>
<p>众所周知，如何删除一条防火墙规则和如何创建一条防火墙规则一样重要，<code>UFW</code> 提供了两种路径删除他们：</p>
<ul>
<li><a href="#%E6%8C%87%E5%AE%9A%E8%A7%84%E5%88%99%E5%BA%8F%E5%8F%B7%E5%88%A0%E9%99%A4">通过规则序号来删除</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%AE%9E%E9%99%85%E8%A7%84%E5%88%99%E5%88%A0%E9%99%A4">通过实际规则来删除</a></li>
</ul>
<h3 id="指定规则序号删除"><a class="header-anchor" href="#指定规则序号删除">¶</a>指定规则序号删除</h3>
<p>每一个规则在创建时都会分配一个序号，你可以将它理解为数据库的自增 <code>ID</code> 吧，可以通过他来进行更方便的操作，你可以通过如下方式查看序号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status numbered</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Numbered Output:</span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">     To                         Action      From</span><br><span class="line">     --                         ------      ----</span><br><span class="line">[ 1] 22                         ALLOW IN    15.15.15.0/24</span><br><span class="line">[ 2] 80                         ALLOW IN    Anywhere</span><br></pre></td></tr></table></figure>
<p>假如你想删除第 <code>2</code> 条规则，拒绝所有指向 <code>80</code> 端口的连接，如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw delete 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：如果你启用了 IPv6 规则，这同时也将删除相应的 IPv6 规则。</strong></p>
</blockquote>
<h3 id="指定实际规则删除"><a class="header-anchor" href="#指定实际规则删除">¶</a>指定实际规则删除</h3>
<p>如果你不想通过 <em>规则序号</em> 来删除，你可以指定 <strong>创建时的参数格式</strong> 来删除，例如：当你使用 <code>sudo ufw allow http</code> 创建的规则时，你可以通过如下方式删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw delete allow http</span><br></pre></td></tr></table></figure>
<p>同样你可以指定端口号来替代服务名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw delete allow 80</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：这种方式将会同时删除相应的 IPv4 和 IPv6规则。</strong></p>
</blockquote>
<h2 id="关闭-ufw"><a class="header-anchor" href="#关闭-ufw">¶</a>关闭 UFW</h2>
<p>现在，由于某些我们不想开启防火墙了，我们可以关闭它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>
<h2 id="重置-ufw-的配置"><a class="header-anchor" href="#重置-ufw-的配置">¶</a>重置 UFW 的配置</h2>
<p>将入你配置了好多规则，但是你现在需要重新配置，抛弃之前的配置规则，你可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw reset</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>这个命令将会删除你之前配置的所有规则，但是默认规则将会被保留。</strong></p>
</blockquote>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>服务器安全一直都是一个重要的话题，开启防火墙使我们保护服务器安全的重要手段之一，所以，无论什么情况下，我们都应该为服务器开启防火墙。当然，开放 <code>SSH</code> 也是必不可少的，与此同时，你可以允许一些连接到您的服务器，同时并限制一些不必要的连接，这样您的服务器才会更加的安全的提供服务。</p>
<p>想了解更多的 <code>UFW</code> 防火墙配置，你可以参考这篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL3Vmdy1lc3NlbnRpYWxzLWNvbW1vbi1maXJld2FsbC1ydWxlcy1hbmQtY29tbWFuZHM=" title="https://www.digitalocean.com/community/tutorials/ufw-essentials-common-firewall-rules-and-commands">UFW Essentials: Common Firewall Rules and Commands<i class="fa fa-external-link"></i></span></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UFW&lt;/code&gt;(Uncomplicated Firewall) 是一个非常容易上手的 &lt;code&gt;iptables&lt;/code&gt; 类防火墙配置工具，这个工具可以对出入服务的网络数据进行分割、过滤、转发等等细微的控制，进而实现诸如防火墙、 &lt;code&gt;NAT&lt;/code&gt; 等功能。它简化了 &lt;code&gt;iptable&lt;/code&gt; 那复杂的配置过程。我们都知道 &lt;code&gt;iptable&lt;/code&gt; 非常强大、灵活，但是对于初学者来学习如何使用它正确的配置防火墙是比较难的，但是你又想保护你的网络，&lt;code&gt;UFW&lt;/code&gt; 将会是你最好的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.charleslxh.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.charleslxh.top/tags/linux/"/>
    
      <category term="Firewall" scheme="http://blog.charleslxh.top/tags/firewall/"/>
    
      <category term="UFW" scheme="http://blog.charleslxh.top/tags/ufw/"/>
    
      <category term="Security" scheme="http://blog.charleslxh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Redis 基础之命令详解</title>
    <link href="http://blog.charleslxh.top/2017/05/20/Redis-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.charleslxh.top/2017/05/20/Redis-基础之命令详解/</id>
    <published>2017-05-20T01:53:53.000Z</published>
    <updated>2019-06-26T11:28:03.717Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Redis" scheme="http://blog.charleslxh.top/categories/redis/"/>
    
    
      <category term="Redis" scheme="http://blog.charleslxh.top/tags/redis/"/>
    
  </entry>
  
</feed>
